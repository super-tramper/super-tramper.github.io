<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>IMTE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="IMTE">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="IMTE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="IMTE">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="IMTE" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">IMTE</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网络层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/05/%E7%BD%91%E7%BB%9C%E5%B1%82/" class="article-date">
  <time datetime="2019-03-05T14:38:38.000Z" itemprop="datePublished">2019-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/05/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>简单网络中的报文传输过程：主机A向网络中的主机B发送一个报文，A中的网络层取得来自A运输层的报文段，将每个报文段封装成一个数据报，然后将数据报向相邻路由器R1发送。在主机B侧，网络层接收来自相邻路由器R2的数据报，提取出运输层报文段，并向上交付给B的运输层。其中路由器的作用是将数据报从入链路转发到出链路。</p>
<h3 id="转发和路由选择"><a href="#转发和路由选择" class="headerlink" title="转发和路由选择"></a>转发和路由选择</h3><p><code>转发</code>：当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。<br><code>路由选择</code>：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法。转发是一个路由器本地操作，路由选择是网络范围的过程。<br><code>转发表</code>：每台路由器都具有一张转发表，路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在路由器的转发表中索引查询。分组首部中的值可能是该分组的目的地址或该分组所属连接的指示，这取决于网络层协议。路由器接收的路由选择协议报文被用于配置其转发表。</p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p>网络服务模型定义了分组在发送与接收端系统之间的端到端运输特性。网络层能提供的特定服务如下：</p>
<ul>
<li>1.确保交付：该服务确保分组将最终到达其目的地。</li>
<li>2.具有时延上界的确保交付：该服务不仅确保分组交付，而且在特定的主机到主机时延上界内交付。</li>
<li>3.有序分组交付：该服务确保分组以它们发送的顺序到达目的地。</li>
<li>4.确保最小带宽：这种网络层服务模仿在发送和接收主机之间的一条特定比特率的传输链路的行为，只要分组以低于特定比特率的速率传输比特，则分组不会丢失，且每个分组会在预定的主机到主机时延内到达。</li>
<li>5.确保最大时延抖动：确保位于发送方的两个相继分组之间的时间量等于（或在允许误差范围内）在目的地接收到它们之间的时间量。</li>
<li>6.安全性服务：使用仅由源和目的主机所知晓的一个秘密会话秘钥，在源主机中的网络层能够加密向目的主机发送的所有数据报负载。</li>
</ul>
<p>因特网的网络层提供了单一的尽力而为服务。ATM网络体系结构则提供了多重服务模型，以下为两个ATM服务模型实例：</p>
<ul>
<li>恒定比特率（CBR）ATM网络服务：使用CBR服务模型的ATM信元流跨越网络时传递时，信元的端到端时延、信元端到端时延中的可变性（时延抖动）及丢失或推迟交付信元的比率都确保在特定值以下。第一次建立CBR连接时，发送主机及ATM网络都认可了这些值。</li>
<li>可用比特率（ABR）ATM网络服务：ABR服务下的信元也许会丢失，但信元不能被重排序，它的最新信元传输速率（MCR）是可以保证的。ATM ABR服务能够为发送方提供反馈信息，以便发送方在MCR和一个允许的峰值信元速率之间调整其速率。</li>
</ul>
<h2 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h2><p>网络层连接/无连接和运输层面向连接/无连接的区别：</p>
<ul>
<li>网络层中，是网络层向运输层提供的主机到主机的服务；运输层中，是运输层向应用层提供的进程到进程的服务。</li>
<li>仅在网络层提供连接服务的计算机网络称为<code>虚电路（VC）网络</code>；仅在网络层提供无连接服务的计算机网络称为<code>数据报网络</code>。没有哪种网络体系结构能同时提供这两种服务。</li>
<li>运输层面向连接服务在位于网络边缘的端系统中实现，网络层连接服务除了在端系统中，也在位于网络核心的路由器中实现。</li>
</ul>
<h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><p>因特网是数据报网络，许多其它网络体系结构却是虚电路网络，在网络层使用连接。</p>
<p>虚电路的组成如下：</p>
<ul>
<li>源和目的主机之间的路径；</li>
<li>VC号，沿着该路径的每段链路的一个号码；</li>
<li>沿着该路径的每台路由器中的转发表项</li>
</ul>
<p>属于一条虚电路的分组将在它的首部携带一个VC号，一条虚电路在每条链路上可能具有不同的VC号，每台中间路由器必须使用一个新的VC号替代每个传输分组的VC号，新的VC号从转发表获得。</p>
<p>虚电路中有3个阶段：</p>
<ul>
<li>1.虚电路建立：发送运输层与网络层联系，指定接收方地址，等待网络建立虚电路。网络层决定发送方与接收方之间的路径。网络层在沿着路径的每台路由器的转发表中增加一个表项，在建立过程中，网络层还可以预留该虚电路路径上的资源。</li>
<li>2.数据传送</li>
<li>3.虚电路拆除：当发送方或接收方通知网络层它希望终止该虚电路时启动这个阶段。网络层将通知网络另一侧的端系统结束呼叫，并更新路径上每台路由器中的转发表以表明该虚电路已不存在了。</li>
</ul>
<p>网络层虚电路建立与运输层连接建立的区别：运输层的连接仅涉及两个端系统，网络中的路由器对此毫不知情；虚电路中，两个端系统之间路径上的路由器都要参与虚电路的建立，且每台路由器都完全知道经过它的所有虚电路。</p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p>在数据报网络中，每当一个端系统要发送分组，它就为该分组加上目的端系统的地址，然后将分组推进网络中。</p>
<p>在传输分组的过程中，路径上所有路由器都使用分组的目的地址来转发该分组。</p>
<p>每台路由器都有一个将目的地址映射到链路接口的转发表，路由器用分组的目的地址齐纳追与该表中的表项进行匹配；如果存在一个匹配项，则路由器向与该匹配项相联系的链路转发分组。当有多个匹配时，路由器使用最长前缀匹配规则。</p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p>路由器的组成部分：</p>
<ul>
<li>输入端口：执行将一条输入的五连链路与路由器相连接的功能、与位于入链路远端的数据链路层交互的数据链路层功能、完成查找功能（通过查询转发表决定路由器的输出端口）。</li>
<li>交换结构：将路由器的输入端口与输出端口相连接，它是网络路由器中的网路。</li>
<li>输出端口：存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输入链路上传输这些分组。</li>
<li>路由选择处理器：执行路由选择协议，维护路由选择表以及连接的链路状态信息，并为路由器计算转发表。执行网络管理功能。</li>
</ul>
<p>路由器的输入端口、输出端口和交换结构共同实现转发功能，该功能被称为路由转发平面，在纳秒时间尺度运行，通常由硬件来实现；路由器的控制功能以毫秒或秒的时间尺度运行，路由控制平面通常用软件实现并在路由选择处理器上执行。</p>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p>输入端口的线路端接功能与链路层实现了用于各个输入链路的物理层和链路层。路由器使用转发表来查找输出端口，使得到达的分组将能经过交换结构转发到该输出端口。转发表是由路由选择处理器计算和更新的，但转发表的一份影子副本通常会被存放在每个输入端口。</p>
<p>输入端口中必须采取的动作：</p>
<ul>
<li>查找输出端口；</li>
<li>出现物理层和链路层处理；</li>
<li>检测分组的版本号、检验和以及寿命字段，并且重写后两个字段；</li>
<li>更新用于网络管理的计数器</li>
</ul>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><p>交换结构位于一台路由器的核心部位。交换可以用多种方式完成：</p>
<ul>
<li>1.经内存交换，经过共享系统总线一次仅能执行一个内存读/写，故不能同时转发两个分组。</li>
<li>2.经总线交换，输入端口经一根共享总线将分组直接传送到输出端口，一次只有一个分组能跨越总线，不需要路由选择处理器的干预。适用于运行在小型局域网和企业网中的路由器。</li>
<li>3.经互联网络交换，能够并行转发多个分组，若两个不同输入端口的分组具有相同的输出端口，则一个分组必须在输入端等待，某时刻给定总线仅有一个分组能发送。</li>
</ul>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p>输出端口处理取出存放在输出端口内存中的分组并将其发送到输出链路上，执行所需的链路层和物理层传输功能。</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>在输入端口和输出端口都会出现排队，排队的程度和位置取决于流量负载、交换结构的相对速率和线路速率。随着队列的增长，路由器的缓存空间被耗尽，当无内存空间可用时将会出现丢包。</p>
<p>基于相对少量的TCP流量，缓存长度的经验计算方法时，缓存数量（B）应当等于平均往返时延（RTT）乘以链路的容量（C）。当有大量的TCP流（N）流过一条链路时，缓存所需要的数量是B=RTT*C/N^-2。</p>
<p>分组调度程序：在输出端口上排队的分组中选择一个来发送，如先来先服务（FCFS）调度和加权公平排队（WFQ），在提供服务质量保证发面起着关键作用。</p>
<p>主动队列管理（AQM）：分组丢弃与标记策略。<br>随机早期检测（RED）：它是一种AQM算法，为输出队列维护着一个加权平均值。如果平均队列小于最小阈值minth，当一个分组到达时，该分组被接纳进队列；如果队列满或平均队列长度大于最大阈值maxth，则当一个分组到达时，该分组被标记湖丢弃；如果一个分组到达，发现平均队列长度在[minth, maxth]之间时，则该分组以某种概率被标记或丢弃。</p>
<p>线路前部（HOL）阻塞：在一个输入队列中排队的分组必须等待通过交换结构方法送，因为它被位于线路前部的另一个分组所阻塞。</p>
<h3 id="路由选择控制平面"><a href="#路由选择控制平面" class="headerlink" title="路由选择控制平面"></a>路由选择控制平面</h3><p>网络范围的路由选择控制平面是分布式的，不同部分执行在不同的路由器上并且通过彼此发送控制报文进行交互。</p>
<h2 id="网际协议：因特网中的转发与编址"><a href="#网际协议：因特网中的转发与编址" class="headerlink" title="网际协议：因特网中的转发与编址"></a>网际协议：因特网中的转发与编址</h2><p>因特网控制报文协议（ICMP）：因特网的网络层差错和信息报告的协议。</p>
<h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p>IPv4数据报中的关键字段如下：</p>
<ul>
<li><code>版本（号）</code>：这4比特规定了数据报的IP协议版本，通过查看版本号，路由器能够确定如何解释IP数据报的剩余部分。</li>
<li><code>首部长度</code>：IPv4数据报可包含一些可变数量的选项，故需要用这4比特来确定IP数据报中数据部分实际从哪里开始，大多数IP数据报不包含选项，具有20字节的首部。</li>
<li><code>服务类型</code>：服务类型（TOS）包含在IPv4首部中，以便使不同类型的IP数据报（例如实时数据报和非实时流量）能够互相区别开来。</li>
<li><code>数据报长度</code>：这是IP数据报的总长度，以字节计，字段长度为16比特，故IP数据报的理论最大长度为65535字节。</li>
<li><code>标识、标志、片偏移</code>：这三个字段与IP分片有关，新版本的IPv6不允许在路由器上对分组分片。</li>
<li><code>寿命（TTL）</code>：用来确保数据不会永远在网络中循环。每当数据报由一台路由器处理时，该字段的值减1，若TTL减为0，则该数据报必须丢弃。</li>
<li><code>协议</code>：指示了IP数据报的数据部分应该交给哪个特定的运输层协议。协议是将网络层与运输层丙丁到一起的粘合剂，而端口号是将运输层和应用层绑定到一起的粘合剂。</li>
<li><code>首部检验和</code>：用于帮助路由器检测收到的IP数据报中的比特错误。计算方法：将首部中的每2个字节当作一个数，用反码运算对这些数求和，该和的反码存放在检验和字段中。路由器对每个收到的IP数据报计算其首部检验和，若计算结果与字段值不一致，则丢弃该数据报。</li>
<li><code>源和目的IP地址</code>。</li>
<li><code>选项</code>：IP首部的扩展字段。</li>
<li><code>数据（有效载荷</code>）。</li>
</ul>
<h4 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h4><p><code>最大传送单元（MTU）</code>：一个链路层帧能承载的最大数据量。由于链路层协议的MTU严格地限制着IP数据报的长度，故将IP数据报中的数据分片成两个或更多个较小的IP数据报，用单独的链路层帧封装这些较小的IP数据报，然后向输出链路上发送这些帧。</p>
<p>分片发生在路由器中，发送主机为初始数据报设置源和目的地址和标识号。当路由器对其进行分片时，每个新数据报具有初始数据报的源地址、目的地址和标识号。最后一个片的标志比特被设为0，其它片的比特被设为1，偏移字段指定该片应该放在初始IP数据报的哪个位置。</p>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><p>一台路由器有多个接口，每个接口和多个主机接口的网络形成一个子网，每个子网具有一个子网掩码，形如223.1.1.0/24，子网内的主机接口具有223.1.1.xxx形式的IP地址。注意：路由器接口之间也能形成子网。<br><code>接口</code>：主机与物理链路之间的边界。<br><code>无类别域间路由选择（CIDR）</code>：因特网的地址分配策略。<br>CIDR子网寻址：32比特的IP地址被划分为两部分，具有点分十进制数形式a.b.c.d/x，其中x指示了地址第一部分中的比特数。  地址的x最高比特构成了IP地址的网络部分，经常被称为该地址的前缀，组织内部的设备的IP地址将共享相同的前缀。<br><code>分类编址</code>：在CIDR被采用之前的编址方案，具有8、16或24比特子网地址的子网被称为A、B和C类网络。</p>
<p><code>获取一块地址</code>：从ISP获取一组地址；ISP从ICANN获取一块地址。<br><code>获取主机地址</code>：主机地址可以手工配置，也可以通过<code>动态主机配置协议（DHCP）</code>来获取。管理员通过配置DHCP，给定主机每次与网络连接时能得到一个相同的IP地址，或者给主机分配一个临时的IP地址。</p>
<p>DHCP协议的4个步骤：</p>
<ul>
<li><code>DHCP服务器发现</code>：一台新到的主机发现一个要与其交互的DHCP服务器，通过DHCP发现报文来完成。客户在UDP分组中向端口67发送该发现报文。DHCP发现报文的IP数据报中包含广播目的地址255.255.255.255并且使用本机源地址0.0.0.0。</li>
<li><code>DHCP服务器提供</code>：DHCP服务器用DHCP提供报文向DHCP发现报文作出响应。每台服务器提供的报文包含有收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及IP地址租用期</li>
<li><code>DHCP请求</code>：新到达的客户从一个或多个服务器提供中选择一个，并向选中的服务器提供用一个DHCP请求报文进行响应，回显配置参数。</li>
<li><code>DHCP ACK</code>：服务器用DHCP ACK报文对DHCP请求报文进行响应，证实所要求的参数。</li>
</ul>
<h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p><code>具有专用地址的地域</code>：其地址基金对该网络中的设备有意义的网络。<br><code>网络地址转换（NAT）</code>：NAT使能的路由器提供向SOHO内的设备提供IP地址空间，该地址仅在给定的网络中有意义，且同一网络中的设备能使用该地址收发分组。所有离开家庭路由器的报文都拥有一个源IP地址，且所有进入家庭的报文都拥有同一个目的地址。NAT使能路由器对外界隐藏了家庭网络的细节。</p>
<p>路由器通过保持一张NAT转换表来识别报文应该转发分组到哪个内部主机。NAT转换表中包含了端口号及其IP地址。</p>
<h4 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h4><p>NAT穿越越来越多地由通用即插即用（UPnP）提供，UPnP是一种允许主机发现并配置邻近NAT的协议。<br>UPnP允许外部主机使用TCP或UDP向NAT化的主机发起通信会话。</p>
<h3 id="因特网控制报文协议（ICMP）"><a href="#因特网控制报文协议（ICMP）" class="headerlink" title="因特网控制报文协议（ICMP）"></a>因特网控制报文协议（ICMP）</h3><p>ICMP被主机和路由器用来彼此沟通网络层的信息。<br>ICMP报文承载于IP分组之中，ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8字节内容。</p>
<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>此部分内容较为复杂，不适合摘要，建议阅读文档。</p>
<blockquote>
<p>还有链路层、计算机网络安全和网络管理等内容没有摘要，这项工作需要大量的时间，这部分先到此为止。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/03/05/%E7%BD%91%E7%BB%9C%E5%B1%82/" data-id="ckja57eee0008fq1339dievx9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-运输层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/02/%E8%BF%90%E8%BE%93%E5%B1%82/" class="article-date">
  <time datetime="2019-03-02T10:25:33.000Z" itemprop="datePublished">2019-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/02/%E8%BF%90%E8%BE%93%E5%B1%82/">运输层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p><code>运输层</code>位于<code>应用层</code>和<code>网络层</code>之间，为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。</p>
<h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信，即不同主机上的进程能彼此发送报文而无需考虑承载这些报文的物理基础的细节。  </p>
<p>端系统实现运输层协议，而非路由器。在发送端，运输层将从应用程序进程接收到的把稳转换成运输层分组（即运输层报文段）并向目的地发送；在接收端，网络层从数据报中提取出运输层报文，并将该报文段上交给运输层，运输层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层处理接收到的报文段，使该报文段中的数据为接收应用进程使用。</p>
<p>网络应用程序可以使用多种的运输层协议，因特网中有<code>TCP</code>和<code>UDP</code>，每种协议都能为调用的应用程序提供一组不同的运输层服务。</p>
<h3 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h3><p>在协议栈中，运输层位于网络层之上。网络层提供了主机之间的逻辑通信，而运输层协议为运行在不同主机上的进程之间提供了逻辑通信。</p>
<p>计算机网络可以安排多种运输层协议，每种协议为应用程序提供不同的服务模型。运输层协议将来自应用进程的报文移动到网络边缘，但对有关这些报文在网络核心中如何移动不做任何规定。中间路由器既不处理也不识别运输层加在运输层报文中的任何信息。</p>
<p>运输协议能够提供的服务常常受制于底层网络协议的服务模型。如果网络层协议无法为主机之间发送的报文提供时延和带宽保证的话，运输层也就无法为进程之间发送的应用层报文提供时延或带宽保证。</p>
<p>底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。例如，网络层协议会使分组丢失、篡改和冗余，运输协议也能为应用程序提供可靠的数据传输服务；即使网络层不能保证运输层报文段的机密性，运输协议也能使用加密来确保应用程序报文不被入侵者读取。</p>
<h3 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h3><p>因特网网络层协议即<code>网际协议（IP）</code>，它的服务模型是提供<code>尽力而为交付服务（best-effort delivery service）</code>。它尽最大的努力在通信的主机之间交付报文段，但不做任何确保，即<code>不确保交付、报文段的顺序、报文段的完整性</code>，故被称为不可靠服务。</p>
<p>UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为<code>运输层的多路复用与多路分解</code>。</p>
<p>TCP和UDP可以通过在其报文段首部中包括差错检测字段提供完整性检查。进程到进程的<code>数据交付</code>和<code>差错检查</code>是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。UDP流量不可调节，应用程序可以根据其需要以其愿意的任何速率发送数据。</p>
<p>TCP为应用程序提供了可靠数据传输，通过使用流量控制、序号、确认和定时器，TCP能确保按序地、正确地将数据从发送进程交付给接收进程。TCP还提供拥塞控制，它防止任何一条TCP连接用过多流量来淹没通信主机间的链路和交换设备。</p>
<h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p><code>多路分解</code>：将运输层报文段中的数据交付到正确的套接字中的工作。<br><code>多路复用</code>：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层的工作。</p>
<p>运输层多路复用要求：</p>
<blockquote>
<ol>
<li>套接字有唯一的标识符；  </li>
<li>每个报文段都有特殊字段来指示该报文段所要交付到的套接字，这些特殊字段是<code>源端口号</code>和<code>目的端口号</code>字段。</li>
</ol>
</blockquote>
<p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。</p>
<h3 id="无连接的多路复用与多路分解"><a href="#无连接的多路复用与多路分解" class="headerlink" title="无连接的多路复用与多路分解"></a>无连接的多路复用与多路分解</h3><p>一个UDP套接字是由一个二元组来全面标识的，该二元组包含一个目的IP地址和一个目的端口号。</p>
<h3 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h3><p>TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的，两个具有不同IP地址或端口号的到达TCP报文将被定向到两个不同的套接字，除非TCP报文携带了初始创建连接的请求。</p>
<h3 id="web服务与TCP"><a href="#web服务与TCP" class="headerlink" title="web服务与TCP"></a>web服务与TCP</h3><p>当客户向web服务器发送报文段时，所有的报文段（包括初始连接建立报文段和承载HTTP请求的报文段）的目的端口都是80。</p>
<p>如果客户与服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换HTTP报文。如果客户与服务器使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭。</p>
<h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>UDP只做了运输协议能够做的最少工作：复用/分解功能、少量的差错检测。</p>
<p>UDP的优点：</p>
<blockquote>
<p>1.关于何时、发送什么数据的应用层控制更为精细。<br>2.无需建立连接，不会引入建立连接的时延。<br>3.无连接状态。TCP需要在端系统中维护连接状态。这个状态包括接收和发送缓存、拥塞控制参数以及序号和确认号的参数。<br>4.分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。</p>
</blockquote>
<p>UDP的应用：RIP路由选择表的更新、承载网络管理数据（SNMP）、流式音频应用。</p>
<h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><p>UDP首部有四个字段，每个字段由两个字节组成。</p>
<blockquote>
<p>1.源端口号；<br>2.目的端口号；<br>3.长度字段：指示了在UDP报文段中的字节数（首部加数据）；<br>4.检验和：用来检查在该报文段中是否出现了差错。</p>
</blockquote>
<h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>UDP检验和提供了差错检测功能，检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。</p>
<p>发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段。</p>
<p>在接收方，全部的16比特字（包括检验和）加在一起，如果该分组没有引入差错，则在接收方处该和将是1111111111111111。</p>
<p>UDP检验和的必要性：由于不能保证源和目的之间的所有链路都提供差错检测，也无法确保在传输时路由器内存中不引入差错，无法确保逐链路的可靠性，又无法确保内存中的差错检测，UDP就必须在端到端基础上在运输层提供差错检测。</p>
<p>虽然UDP提供差错检测，但它不提供差错恢复，当报文中出现差错时，UDP丢弃受损的报文或向应用程序交付报文段并给出警告。</p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p><code>可靠数据传输协议</code>的服务抽象是：数据可以通过一条可靠的信道进行传输。<br>即：</p>
<blockquote>
<p>1.传输数据比特不会受到损坏或丢失；<br>2.所有数据都是按照其发送顺序进行交付。</p>
</blockquote>
<h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><p><code>自动重传请求（ARQ）协议</code>：接收方向发送方发送控制报文，使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。</p>
<p>ARQ协议中的功能：</p>
<blockquote>
<p>1.差错检测；<br>2.接收方反馈：肯定确认（ACK）和否定确认（NAK）；<br>3.重传</p>
</blockquote>
<p>考虑受损ACK和NAK的情况，当发送方收到含糊不清的ACK和NAK分组时，只需重传当前的数据分组即可。另一个解决办法是在数据分组中添加一新字段，将发送数据分组的序号放在该字段，接收方只需检测序号即可确定收到的分组是否一次重传。  </p>
<p>基于时间的重传机制，引入<code>倒计数定时器</code>：在一个给定的时间量过期后，可中断发送方。<br>发送方需要做到：</p>
<blockquote>
<p>1.每次发送一个分组时，便启动一个定时器；<br>2.响应定时器中断（采取适当的动作）；<br>3.终止定时器。</p>
</blockquote>
<p>通过使用检验和、序号、定时器、肯定和否定确认分组技术，可实现可靠数据传输。</p>
<h3 id="流水线可靠数据传输服务"><a href="#流水线可靠数据传输服务" class="headerlink" title="流水线可靠数据传输服务"></a>流水线可靠数据传输服务</h3><p>停等协议：在发送方确信接收方已正确接收当前分组之前，发送方将不会发送一块新数据。停等协议的方法送分利用率非常低，为了解决这一问题，引入了以下技术。<br><code>流水线</code>：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。<br>流水线技术对可靠数据传输协议可带来如下影响：  </p>
<blockquote>
<p>1.必须增加序号范围<br>2.协议的发送方和接收方两端也必须缓存多个分组。<br>3.所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：<code>回退N步（GBN）</code>、<code>选择重传（SR）</code>。</p>
</blockquote>
<h3 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h3><p><code>回退N步（GBN）协议</code>：允许发送方发送多个分组而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数。<br>回退N步协议保持一个在序号范围内长度为N的窗口，是出于流量控制，对发送方施加限制。<br>GBN发送方必须响应三种类型的事件：  </p>
<blockquote>
<p>1.上层的调用，响应上层调用时，发送方首先检测发送窗口是否已满：若窗口未满，则产生一个分组并将其发送；若窗口未满发送方只需将数据返回给上层，隐式地指示上层窗口已满。<br>2.收到一个ACK：对分组的确认采用累积确认的方式，表明接收方已正确收到序号为n的以前包括n在内的所有分组。<br>3.超时事件：如果出现超时，发送方重传所有已发送但还未被确认过的分组，如果收到一个ACK，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已发送但未被确认的分组，该定时器被终止。  </p>
</blockquote>
<p>GBN接收方的动作：如果一个序号为n的分组被正确接收到，<code>并且按序</code>，则接收方为分组n发送一个ACK，并将该分组中的数据部分交付到上层。在其它所有情况下，丢弃该分组，并为最近按序接收的分组重新发送ACK。  </p>
<p>在GBN中，发送方必须维护窗口的上下边界及nextseqnum在该窗口中的位置，但接收方需要维护的唯一信息就是下一个按序接收的分组的序号。</p>
<h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><p>随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥，选择重传（SR）协议通过让对方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。</p>
<p>SR发送方的事件与动作：</p>
<blockquote>
<p>1.从上层收到数据：从上层收到数据后，SR发送方检查下一个可用于该分组的序号，若序号位于发送方的窗口内，则将数据打包发送，否则同GBN。<br>2.超时：每个分组必须拥有自己的逻辑定时器，超时发生后只能发送一个分组。<br>3.收到ACK：若ACK对应分组的序号在窗口内，则SR发送方将那个被确认的分组标记为已接收，过序号为send_base，则移动窗口到具有最小序号的未确认分组处。窗口移动了且有序号落在窗口内的未发送分组，则发送这些分组。  </p>
</blockquote>
<p>SR接收方的事件与动作：</p>
<blockquote>
<p>1.序号在[rcv_base, rcv_base+N-1]内的分组被正确接收：收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。若该分组以前没有收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号（rcv_base），则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。<br>2.序号在[rcv_base-N, rcv_base-1]内的分组被正确收到：必须产生一个ACK，即使该分组时接收方以前已确认过的分组。<br>3.其它情况：忽略该分组。  </p>
</blockquote>
<p>应用SR协议时，窗口长度必须小于或等于序号空间大小的一半。</p>
<h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><p>TCP实现可靠数据传输，依赖于差错检测、重传、累积确认、定时器以及用于序号和确认号的首部字段。  </p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP的连接状态会完全保留在两个端系统中。中间的网络元素不会维持TCP连接状态。中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接。</p>
<p>TCP连接提供的是全双工服务，应用层数据可在从进程B流向进程A的同时，也从进程A流向进程B。</p>
<p><code>最大报文长度（MSS）</code>：TCP可从缓存中取出并放入报文段中的数据量受限于MSS（报文段里应用层数据的最大长度，不包括TCP首部），MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即<code>最大传输单元MTU</code>）来设置。MSS的值要保证一个TCP报文段加上TCP/IP首部长度将适合单个链路层帧，以太网和PPP链路层协议都具有1500字节的MTU，MSS的典型值为1460字节。</p>
<p>TCP数据传输过程：TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段，这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的接收缓存中，应用程序从此缓存中读取数据流。</p>
<p>TCP的连接组成包括：发送方和接收方两台主机上的缓存、变量和与进程连接的套接字。</p>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p>TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。</p>
<p>首部一般是20字节，其结构为：</p>
<blockquote>
<p>1.<code>源端口号</code>和<code>目的端口号</code>：用于多路复用/分解来自或送到上层应用的数据；<br>2.<code>检验和字段</code>；<br>3.32比特的<code>序号字段</code>和32比特的<code>确认号字段</code>：被TCP发送方和接收方用来实现可靠数据传输服务；<br>4.16比特的<code>接收窗口字段</code>：用于流量控制，指示接收方愿意接受的字节数量；<br>5.4比特的<code>首部长度字段</code>：指示了以32比特的字节为单位的TCP首部长度；<br>6.可选与变长的<code>选项字段</code>：用于发送方与接收方协商最大报文段（MSS）时，或在告诉网络环境下用作窗口调节因子时使用；<br>7.6比特的<code>标志字段</code>：ACK比特用于指示确认字段中的值是有效的，RST、SYN和FIN比特用于连接建立和拆除。当PSH比特被设置的时候，指示接收方应立即将数据交给上层，URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据，紧急数据存在并给出指向紧急数据尾的指针的时候，TCP必须通知接收端的上层实体。</p>
</blockquote>
<h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p>这是TCP报文段首部中两个最重要的字段。</p>
<p>报文段的序号是该报文段首字节的字节流编号，一条TCP连接的双方均可随机地选择初始编号。</p>
<p>累积确认：TCP只确认该流中至第一个丢失字节为止的字节。</p>
<h3 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h3><p>大多数TCP的实现仅在某个时刻做一次SampleRTT(样本往返时间）测量，且绝不为已被重传的报文段就算SampleRTT。<br>一旦获得一个新SampleRTT时，TCP就会根据下列公式来更新EstimatedRTT:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EstimatedRTT&#x3D;(1-a)*EstimatedRTT+a*SampleRTT</span><br></pre></td></tr></table></figure>

<p>[RFC 6298]中给出的a的参考值为0.125，这种平均被称为指数加权移动平均（EWMA）。  </p>
<p>RTT偏差DevRTT，用于估算SampleRTT一般会偏离EstimatedRTT的程度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DevRTT&#x3D;(1-b)*DevRTT+b|DevRTT-EstimatedRTT|</span><br></pre></td></tr></table></figure>

<p>b的推荐值为0.25，如果SampleRTT的值波动较小，DevRTT的值就会变小，vise verse。</p>
<p>TCP重传超时间隔TimeoutInterval:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeoutInterval&#x3D;EstimatedRTT+4*DevRTT</span><br></pre></td></tr></table></figure>

<p>推荐的初始TimeoutInterval值为1秒，当出现超时后，TimeoutInterval的值将加倍。</p>
<h3 id="可靠数据传输-1"><a href="#可靠数据传输-1" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流。</p>
<p>TCP只用超时来恢复报文段的丢失，TCP与发送和重传有关的主要事件：</p>
<blockquote>
<p>1.从应用程序接收数据：TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP，TCP启动定时器，定时器的过期间隔是TimeoutInterval。<br>2.超时：TCP通过重传引起超时的报文段来响应超时事件。然后重启定时器。<br>3.接收方确认报文段（ACK）的到达：TCP将ACK的值y与它的变量SendBase进行比较，如果y大于SendBase，则该ACK是在确认一个或多个先前未被确认的报文段，发送方更新它的SendBase变量；若当前有未被确认的报文段，TCP还要重启定时器。</p>
</blockquote>
<p>超时时间间隔加倍：每次TCP重传时都将下一次的超时间隔设为先前的两倍，每当定时器在收到上层应用的数据或收到ACK时，TimeoutInterval由最近的EstimatedRTT和DevRTT值推算得到。</p>
<p>快速重传：一旦收到3个冗余ACK，TCP就在该报文段的定时器过期之前重传丢失的报文段。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制将发送方的速率与接收方应用程序的读取速率相匹配，意在消除发送方使接收方缓存溢出的可能性。</p>
<p>TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制。  </p>
<p>下式必须成立：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastByteRcvd-LastByteRead&lt;&#x3D;RcvBuffer</span><br></pre></td></tr></table></figure>

<p>接收窗口rwnd根据可用空间的数量来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwnd&#x3D;RcvBuffer-[LastByteRead-LastByteRcvd]</span><br></pre></td></tr></table></figure>

<p>发送方在连接的整个生命周期内必须保证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastByteSent-LastByteAcked&lt;&#x3D;rwnd</span><br></pre></td></tr></table></figure>

<p>当接收方的接收窗口为0时，发送方继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认，当缓存开始清空，确认报文里将包含一个非0的rwnd值。</p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>三次握手：</p>
<blockquote>
<p>1.客户端TCP首先向服务端的TCP发送一个特殊的报文段，该报文中不包含应用层数据，但是在报文段首部的标志位（SYN比特）被置为1。客户随机选择一个初始序号（client_isn），并将此编号防止在起始的TCP SYN报文段的序号字段中；<br>2.包含TCP SYN报文段的IP数据报到达服务器主机，服务器从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户TCP发送允许连接的报文段（SYNACK报文段）。该报文段中SYN比特被置为1，首部的确认号字段被置为client_isn+1。服务器选择自己的初始序号（server_isn），并将其防止到TCP报文段首部的序号字段中；<br>3.客户收到SYNACK报文段后，为该连接分配缓存和变量，客户主机性服务器发送另外一个报文段，这最后一个报文段对服务器的允许连接的报文段进行了确认，SYN比特被置为0，确认报文可以在报文段负载中携带客户到服务器的数据。</p>
</blockquote>
<p>建立连接后的每一个报文段中，SYN比特都将被置为0.</p>
<p>四次挥手：</p>
<blockquote>
<p>1.客户TCP向服务器进程发送一个特殊的TCP报文段，首部中的FIN比特标志位被置为1；<br>2.服务器收到该报文，向发送方回送一个确认报文段；<br>3.服务器发送它自己的终止报文段，其FIN比特被置为1；<br>4.客户对这个服务器的终止报文段进行确认。</p>
</blockquote>
<p>若服务器收到一个SYN请求，但端口号或源IP地址与该主机上进行中的套接字不匹配，则服务器向该主机发送一个特殊重置报文段。该报文段将RST标志位置为1。</p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>拥塞控制的必要性：若链路上的路由器具有无穷大缓存的路由器，当分组的到达速率接近链路容量时，分组经历巨大的排队时延；若链路上的路由器具有有限缓存，发送方发送速率过大引起路由器缓存溢出，发送方必须执行重传以补偿因缓存溢出而丢失的分组，当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量被浪费。</p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p><code>端到端拥塞控制</code>： 在此方法中，网络层没有为运输层拥塞控制提供显式支持，TCP使用增加的往返时延值作为网络拥塞程度增加的指示。</p>
<p><code>网络辅助的拥塞控制</code>：网络层构件向发送方提供关于网络中拥塞状态的显式反馈信息。在此方法中，网络层可用两种方法发送反馈信息：采用阻塞分组的形式、路由器标记或更新从发送方流向接收方分组中的某个字段来指示拥塞的产生。</p>
<h4 id="例子：ATM-ABR拥塞控制"><a href="#例子：ATM-ABR拥塞控制" class="headerlink" title="例子：ATM ABR拥塞控制"></a>例子：ATM ABR拥塞控制</h4><p><code>ATM</code>:异步传递方式网络<br><code>ABR</code>:可用比特率</p>
<p>对于ATM ABR服务，数据信源从源经过一系列中间交换机传输到目的地。在数据信源中夹杂着资源管理信元（RM信元），这些RM信元可被用来在主机和交换机之间传递与拥塞相关的信息。当一个RM信元到达目的地时，它将被调转方向并向发送方发送。交换机也有可能自己产生一个RM信元，并将该RM信元直接发送给源。</p>
<p>ABR提供三种机制用于从交换机向接收方发送与拥塞相关的信令信息：</p>
<blockquote>
<p><code>EFCI比特</code>：每个数据信元都包含1比特的显示转发拥塞指示（EFCI）比特，某拥塞网络的交换机可把一个数据信元中的EFCI比特置为1来向目的主机发送网络已经拥塞的信令。当RM信元到达目的地时，如果多数近来收到的数据信元的拥塞指示比特（CI比特）都被置为1，则目的地就会将RM信元的拥塞指示比特置为1，并将该RM信元发送回接收方。使用数据信元中的EFCI比特和RM信元中的CI比特，发送方因而能够在网络交换机拥塞时得到通知。<br><code>CI和NI比特</code>：RM信元的夹杂比率是一个可调参数，默认值是每32个数据信元中有一个RM信元。这些RM信元中有一个拥塞指示（CI）比特和无增长（NI）比特，这两个比特可被一台拥塞的交换机设置。交换机可在轻微拥塞时将经过的RM信元的NI比特置为1，在严重拥塞时，把CI比特置为1，目的主机收到RM信元时，把该RM信元发回给发送方而保持NI和CI比特不变。<br><code>ER的设置</code>：每一个RM信元还包含一个两字节的显式速率（ER）字段。拥塞的交换机也许会降低经过RM信元中ER字段所包含的值，ER字段将被设置为在源至目的地的路径上的所有交换机中的最小可支持速率。</p>
</blockquote>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP必须使用端到端拥塞控制而不是使用网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。</p>
<p>TCP所使用的原则：</p>
<ul>
<li>一个丢失的报文段意味着拥塞，因此当丢失报文段时应降低TCP发送方的速率。一个超时事件或四个确认被解释为跟随报文段的丢包事件的隐含的指示，对此，TCP发送方应减小它的拥塞窗口长度以减小其发送速率。</li>
<li>一个确认报文段指示该网络正在向接收方交付发送方的报文段。因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。</li>
<li>带宽探测：TCP在ACK到达时增加其速率，当出现丢包时减小其速率。TCP发送方增加它的传输速率，从丢包时的速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化。</li>
</ul>
<p>TCP拥塞控制算法包括三个主要部分：<code>慢启动</code>、<code>拥塞避免</code>、<code>快速恢复</code>。</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>TCP发送方希望迅速找到可用带宽的数量，在慢启动状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。</p>
<p>结束慢启动的三种方式：</p>
<ul>
<li>1.如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1MSS并重新开始慢启动过程。它还将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2。</li>
<li>2.当检测到拥塞时sstresh设为cwnd的一半，当达到或超过ssthresh的值时，结束慢启动并且TCP转移到<code>拥塞避免</code>模式。</li>
<li>3.当检测到3个冗余ACK，TCP执行一次快速重传并进入<code>快速恢复</code>状态。</li>
</ul>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>TCP发送方无论何时到达一个新的确认，就将cwnd增加一个<code>MSS(MSS/cwnd)</code>字节。当丢包事件出现时,ssthresh的值被更新为cwnd的一半，当出现超时时，cwnd的值被设置为1MSS。</p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。如果出现超时事件，快速恢复执行如同在慢启动和拥塞避免中的相同动作后，迁移到慢启动状态。</p>
<p>快速恢复是TCP推荐的而非必须的构建。</p>
<blockquote>
<p>四天时间摘要复习完运输层这一章，详细了解了运输层的运行机制，其中TCP拥塞控制这部分还需要反复琢磨。  </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/03/02/%E8%BF%90%E8%BE%93%E5%B1%82/" data-id="ckja57eeh000cfq130wuu90uu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-应用层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/13/%E5%BA%94%E7%94%A8%E5%B1%82/" class="article-date">
  <time datetime="2019-02-13T13:58:27.000Z" itemprop="datePublished">2019-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/13/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>研发网络应用程序的核心：写出能够运行在不同的端系统和通过网络彼此通信的程序。<br>网络核心设备并不在应用层起作用，特别是网络层及下面层次，应用被限制在端系统。  </p>
<h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><p>应用程序体系结构：由应用程序研发者设计，规定了如何在各种端系统上组织该应用结构。<br>客户-服务器体系结构（cs architecture):总是打开的主机服务于来自客户主机的请求，服务器具有固定的IP，客户机之间不能直接通信，客户机能随时从服务器获得服务，服务方通常具有配备大量主机的数据中心。  </p>
<p>P2P结构（P2P architecture):对服务器的依赖很小或没有，主机对之间间断连接，适用于流量密集型应用。  </p>
<p>P2P结构的自扩展性：每个对等方都请求文件产生工作量，但每个对等方都通过分发文件为系统增加服务能力。  </p>
<p>P2P应用面临的挑战：  </p>
<blockquote>
<ol>
<li>硬件设施限制了P2P的上载流量；   </li>
<li>高分布、开放的特性带来的安全性问题；  </li>
<li>用户向应用提供带宽的意愿。</li>
</ol>
</blockquote>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>运行在相同端系统上的进程（process）使用进程间通信机制相互通信，规则由端系统上的操作系统确定；  </p>
<p>运行在不同端系统上的进程通过跨越计算机网络交换报文（message）来通信。</p>
<h4 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h4><p>客户：发起通信的进程；  </p>
<p>服务器：会话开始时等待连接的进程。  </p>
<h4 id="进程云计算机网络之间的接口"><a href="#进程云计算机网络之间的接口" class="headerlink" title="进程云计算机网络之间的接口"></a>进程云计算机网络之间的接口</h4><p>套接字（socket）：进程向网络发送报文和接收报文时所使用的软件接口，也称为应用程序和网络之间的应用程序编程接口。  </p>
<p>应用程序开发者对套接字的控制权：  </p>
<blockquote>
<ol>
<li>选择运输层协议</li>
<li>设置运输层参数</li>
</ol>
</blockquote>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>标识接收进程需要定义两种信息：IP地址、目的端口号</p>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><p>可通过以下方面的需要来选择可用的运输层协议：</p>
<ul>
<li>可靠数据传输：从应用程序端把数据正确、完整地交给另一端；</li>
<li>吞吐量：发送进程能够接受进程交付比特的速率；</li>
<li>定时：分组从发送方套接字到进入接收方套接字不迟于一定时间；</li>
<li>安全性：发送加密、交付解密、数据完整性、端点界别等。</li>
</ul>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><p>面向连接： 在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息，以建立连接，连接双方的进程可在此连接上同时进行报文收发（全双工）。  </p>
<p>可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。  </p>
<p>拥塞机制：发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程。</p>
<h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><p>轻量级、无拥塞（时序错乱、丢失数据）、不可靠</p>
<h4 id="因特网运输协议不提供的服务"><a href="#因特网运输协议不提供的服务" class="headerlink" title="因特网运输协议不提供的服务"></a>因特网运输协议不提供的服务</h4><p>定时、吞吐量</p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>应用层协议（application-layer protocol）：定义运行在端系统上的应用程序进程如何互相传递报文。  </p>
<p>应用层协议是网络应用的一部分。  </p>
<p>定义内容：</p>
<blockquote>
<ol>
<li>交换的报文类型；</li>
<li>各种报文类型的语法；</li>
<li>字段的语义</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则</li>
</ol>
</blockquote>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>web的应用层协议是超文本传输协议（HyperText Transfer Protocol）。  </p>
<p>HTTP由两个程序实现：客户端程序和服务器程序。  </p>
<p>对象：一个文件，如HTML文件，JPEG图形等。  </p>
<p>多数web页面含有一个HTML基本文件以及几个引用对象。  </p>
<p>HTTP定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式。  </p>
<p>HTTP使用TCP作为它的支撑运输协议。  </p>
<p>无状态协议：HTTP服务器并不保存客户的任何信息。</p>
<h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p>往返时间（Round-Trip Time, RTT）：一个短分组从客户到服务器然后再返回客户所花费的时间，包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。  </p>
<p>非持续连接：每个请求/响应对是经一个单独的TCP连接发送，总响应时间是两个RTT加上服务器传输HTML文件的时间。   </p>
<p>持续连接：所有请求/响应对是经相同的TCP连接发送。  </p>
<h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><ul>
<li>由普通的ASCII文本书写；</li>
<li>每行由一个回车和换行符结束，最后一行再附加一个回车换行符；</li>
<li>第一行：请求行；</li>
<li>后继行：首部行；</li>
<li>请求行（request line）：方法字段、URL字段、HTTP版本字段；</li>
<li>首部行（header line）：<code>Connection:close</code>  不使用持续连接，要求服务器在发送完请求的对象后关闭连接</li>
<li>首部行：<code>User-agent: </code>指明用户代理，即浏览器的类型。</li>
<li>实体体（entity body）：使用GET方法时为空、使用POST方法时才使用该实体体；</li>
<li>当服务器收到HEAD方法的请求时，会用一个HTTP报文进行响应，但是并不返回请求对象。</li>
</ul>
<h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><ul>
<li>由状态行、首部行、实体体组成；</li>
<li>状态行：协议版本、状态码、响应状态信息</li>
<li>首部行：<code>Connection:close</code> 发送完报文后将关闭TCP连接、<code>Date：</code>服务器产生并发送该响应报文的日期和时间，是服务器从文件系统中检索到该对象，插入到响应报文并发送的时间、<code>Server:</code>指示由什么服务器产生的报文、<code>Last-Modified:</code>指示了对象创建或者最后修改的日期和时间、<code>Content-Length：</code>被发送对象中的字节数、<code>Content-Type：</code>指示了实体体中的对象时HTML文本；</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>作用：允许站点对用户进行跟踪，识别用户<br>四大组件：  </p>
<ul>
<li>在HTTP响应报文中的一个cookie首部行；</li>
<li>在HTTP请求报文中的一个cookie首部行；</li>
<li>在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理；</li>
<li>位于web站点的一个后端数据库。</li>
</ul>
<p>使用过程：首次与一个网站联系，服务器用一个包含<code>Set-cookie</code>首部的HTTP响应报文对浏览器进行响应，浏览器在它管理的特定cookie文件中添加一行，包含服务器的主机名和在<code>Set-cookie</code>首部中的识别码，每当该浏览器请求一个该网站的web页面时，浏览器会自动从cookie文件中获取他对这个网站的识别码并放到请求报文中的cookie首部行中。</p>
<h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>web缓存器（Web cache)<br>代理服务器（proxy server）  </p>
<p>作用：</p>
<ul>
<li>减少对客户请求的响应时间</li>
<li>减少机构接入因特网的通信量</li>
<li>降低因特网上的web流量、改善应用性能</li>
</ul>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>HTTP协议可使缓存器正式它的对象时最新的，即条件GET方法<br>特征：</p>
<ul>
<li>请求报文使用GET方法</li>
<li>请求报文中包含一个<code>If-Modified-Since:</code>首部行</li>
</ul>
<h2 id="文件传输协议：FTP"><a href="#文件传输协议：FTP" class="headerlink" title="文件传输协议：FTP"></a>文件传输协议：FTP</h2><p>用户提供用户标识和口令，简历与server的连接，与server进行文件传输。<br>与HTTP的共同点：</p>
<ul>
<li>都是文件传输协议</li>
<li>都运行在TCP上</li>
</ul>
<p>与HTTP的不同，FTP使用两个并行的连接来传输文件，一个是控制连接，一个是数据连接。FTP的控制信息是带外（out-of-band）传送的，HTTP在带内（in-band）传送控制信息。  </p>
<p>控制连接：在两主机之间传输控制信息，例如用户标识、口令、改变远程目录的命令以及存放和获取文件的命令。<br>数据连接：用于实际发送一个文件。  </p>
<p>控制连接贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的数据连接。FTP服务器必须在整个会话期间保留用户的状态，服务器需要把特定的用户账户与控制连接联系起来，追踪用户在远程目录树上的当前位置，对每个进行中的用户会话的状态信息进行追踪。  </p>
<h3 id="FTP命令和回答"><a href="#FTP命令和回答" class="headerlink" title="FTP命令和回答"></a>FTP命令和回答</h3><p>FTP的命令和回答都是以7比特ASCII格式在控制连接上传送的，每个命令后跟回车换行符，每个命令由四个大写字母ASCII字符组成，有些还有可选参数。</p>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>电子邮件系统的主要组成部分：用户代理、邮件服务器、简单邮件传输协议。</p>
<p>邮件发送过程：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收放的邮件服务器，然后在这里被分发到接收方的邮箱中。</p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP是邮件中主要的应用层协议，运行在25端口，由两部分组成：运行在发送方邮件服务器的客户端和运行在接收方邮件的服务器端，每台邮件服务器上既运行SMTP的客户端也运行SMTP的服务器端。</p>
<p>SMTP使用持续连接，用于发送多个报文，一般不使用中间邮件服务器发送邮件。</p>
<h3 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h3><p>相同点：都用于从一台主机向另一台主机传送文件，持续的HTTP和SMTP都使用持续连接。</p>
<p>区别：</p>
<ul>
<li>HTTP是一个拉协议（pull protocol），SMTP是一个推协议（push protocol）；</li>
<li>SMTP要求每个报文使用7比特ASCII码格式，HTTP数据不受这种限制；</li>
<li>处理一个既包含文本又包含图形的文档时，HTTP把每个对象封装到自己的HTTP响应报文中，而SMTP则把所有报文对象放在一个报文之中。</li>
</ul>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>格式：</p>
<ul>
<li>首部行和体用空行进行分隔；</li>
<li>每个首部行必须有一个<code>From:</code>和<code>To:</code>首部行，也许会包括<code>Subject:</code>和其它可选的首部行。</li>
</ul>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>第三版的邮局协议POP3、因特网邮件访问协议IMAP、HTTP</p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>端口110，按照三个阶段进行工作：</p>
<ul>
<li>特许：用户代理（明文）发送用户名和口令以鉴别用户，主要命令为<code>user &lt;username&gt;</code>和<code>pass &lt;password&gt;</code>；</li>
<li>事务处理：用户代理取回报文，带报文做删除标记以及获取邮件的统计信息，可使用四个命令<code>list</code>、<code>retr</code>、<code>dele</code>、<code>quit</code>；</li>
<li>更新：出现在客户发出了quit命令结束POP3会话之后，删除那些被标记为删除的报文。</li>
</ul>
<p>事务处理过程：回答为<code>+OK</code>或<code>-ERR</code>，可设置为下载并保留或下载并删除方式，POP3服务保留了一些状态信息，但并不会在POP3会话过程中携带状态信息。</p>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP服务器把每个报文与一个文件夹联系起来，为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令，还为用户提供了在远程文件夹中查询邮件的命令，同时还维护了会话的用户状态信息。</p>
<p>IMAP的一个重要特性是它具有允许用户代理湖区报文组件的命令，例如只读取一个报文的首部，或一个多部分MIME报文的一部分。</p>
<h4 id="基于Web的电子邮件"><a href="#基于Web的电子邮件" class="headerlink" title="基于Web的电子邮件"></a>基于Web的电子邮件</h4><p>电子邮件报文从邮件服务器发送到浏览器，使用的是HTTP。</p>
<h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h2><p>主机可以使用主机名和IP地址进行标识。</p>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>域名系统（DNS）：主机名到IP地址转换的目录服务。</p>
<ul>
<li>由分层的DNS服务器实现的分布式数据库</li>
<li>使主机能够查询分布式数据库的应用层协议</li>
<li>运行在UDP之上，使用53号端口</li>
</ul>
<p>服务的具体内容：</p>
<ul>
<li>主机别名：应用程序可以调用DNS来忽的主机别名队形的规范主机名以及主机的IP地址；</li>
<li>邮件服务器别名：电子邮件应用程序调用DNS对提供的邮件服务器别名进行解析，获得该主机的规范主机名以及IP地址；</li>
<li>负载分配：当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的一个集合进行响应，但在每个回答中循环这些地址次序。</li>
</ul>
<h3 id="DNS工作机理"><a href="#DNS工作机理" class="headerlink" title="DNS工作机理"></a>DNS工作机理</h3><h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><ul>
<li>根DNS服务器：至2011年秋季，全球共有247个根服务器</li>
<li>顶级域（Top-Level Domain, TLD）DNS服务器：负责域名如com、org、net以及所有国家的顶级域名</li>
<li>权威DNS服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录  </li>
<li>本地DNS服务器：每个ISP都有一台本地DNS服务器，本地DNS服务器不属于DNS层次体系结构。</li>
</ul>
<p>当主机与某ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台本地DNS服务器的IP地址，通过访问Windows或Unix的网络状态窗口，能够容易地确定你本地DNS服务器的IP地址。</p>
<p>请求某域名的主机的IP地址：</p>
<blockquote>
<p>1.主机cis.poly.edu向它的本地DNS服务器dns.poly.edu发送一个DNS查询报文，报文中含有被转换的主机名gaia.cs.umass.edu<br>2.本地DNS服务器将该报文转发到根DNS服务器，根DNS向本地DNS服务器返回负责edu的TLD的IP地址列表<br>3.本地DNS服务器再次向这些TLD服务器之一发送查询报文，TLD用权威DNS服务器（dns.umass.edu）的IP地址进行响应<br>4.本地DNS服务器直接向dns.umass.edu重发查询报文，权威DNS用gaia.cs.umass.edu的IP地址进行响应。</p>
</blockquote>
<p>本例子中，第一步为递归查询(recursive query),该查询请求dns.poly.edu以自己的名义获得该映射。后继的3个查询是迭代查询(iterative query)，因为所有的回答都是直接返回给dns.poly.edu。</p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS缓存能改善时延性能并减少在因特网上到处传输的DNS报文数量。<br>每当本地DNS服务器dns.poly.edu从某个DNS服务器接收到一个回答，它能够缓存包含在该回答中的任何信息。如果在DNS服务器中缓存了一台主机名/IP地址对，另一对相同的主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址。  </p>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>共同实现DNS分布式数据库的所有DNS服务器存储了资源记录。资源记录是一个包含了下列字段的4元组：<br>（Name, Value, Type, TTL)<br>TTL是该记录的生成时间，它决定了资源记录应当从缓存中删除的时间。<br>Name和Value的值取决于Type：</p>
<ul>
<li>如果Type=A,则Name是主机名， Value是该主机名对应的IP地址</li>
<li>如果Type=NS，则Name是个域，而Value是个知道如何获得该域中主机IP地址的权威DNS的主机名</li>
<li>如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名</li>
<li>如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名</li>
</ul>
<p>如果一台DNS服务器时用于某特定主机名的权威DNS服务器，那个该DNS服务器会有一条包含该主机名的类型A记录，如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应于包含主机名的域，它还将包含一条类型NS记录，该记录提供了在NS记录的value字段中的DNS服务器的IP地址。</p>
<h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>DNS只有查询和回答报文，并且这两种报文具有相同的格式。</p>
<ul>
<li>前12个字节是首部区域：第一个字段是16比特的数，用于标识该查询，这个标识符会被复制到对查询的回答报文中，标志字段中1比特的“查询/回答”标志位支出报文时查询报文（0）还是回答报文（1）；当某DNS服务器时所请求名字的权威DNS服务器时，1比特的“权威的”标志位被置在回答报文中；如果客户在该DNS服务器没有某记录时希望它执行递归查询，将设置1比特的“希望递归”标志位；如果DNS服务器支持递归查询，将设置1比特的“递归可用”标志位。还有4个有关数量的字段，这些字段指出了在首部后的4类数据区域出现的数量。</li>
<li>问题区域包含正在进行的查询信息：包括名字字段，指出正在被查询的主机名字；类型字段，指出有关该名字的正被询问的问题类型</li>
<li>来自DNS服务器的回答中，回答区域包含了对最初请求的名字的资源记录</li>
<li>权威区域包含了其他权威服务器的记录</li>
<li>附加区域包含了其他有包住的记录</li>
</ul>
<h4 id="在DNS数据库中插入记录"><a href="#在DNS数据库中插入记录" class="headerlink" title="在DNS数据库中插入记录"></a>在DNS数据库中插入记录</h4><p>因特网名字和地址分配机构（ICANN）向各种注册登记机构授权，用户向某些注册登记机构注册域名时，需要向该机构提供基本和辅助权威DNS服务器的名字和IP地址，注册登记机构确保将一个类型NS和一个类型A的记录输入TLD com服务器</p>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p>应用程序从单个源向大量的对等方分发一个文件，服务器承受了极大的负担，并且小号了大量的服务器带宽，每个对等方能够重新分发它所有的该文件的任何部分，从而在分发过程中协助该服务器。</p>
<h4 id="P2P体系结构的扩展性"><a href="#P2P体系结构的扩展性" class="headerlink" title="P2P体系结构的扩展性"></a>P2P体系结构的扩展性</h4><blockquote>
<p>公式推导过程略</p>
</blockquote>
<p>对于客户-服务器体系结构，随着对等方数量的增加，分发时间呈线性增长且没有界；对于P2P体系结构，最小分发时间总是小于cs体系结构的分发时间，并且对于任意的对等方数量N，总是小于文件大小/对等方的上载速率。这叫做P2P体系结构的自扩展性，这种扩展性的直接成因是：对等方处理是比特的消费者外还是它们的重新分发者。</p>
<h4 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h4><p>BitTorrent是一种用于文件分发的流行P2P协议。<br>洪流（torrent）：参与一个特定文件分发的所有对等方的集合。<br>每个洪流具有一个基础设施节点，称为追踪器（tracker），当一个对等方加入某个洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在洪流中。<br>当一个新的对等方A加入洪流时，追踪器随机地从参与对等方的集合中选择对等方的一个子集，并将子集中所有对等方的IP地址发送给A，A持有这张表并试图与该列表上的所有对等方简历并行的TCP连接，所有这样与A建立TCP连接的对等方为临近对等方。在任何时刻，每个对等方将具有来自该文件的块子集，并且不同的对等方具有不同的子集。A周期性地询问每个临近对等方它们所具有的块列表，获得这些列表后，A对它还没有的块发出请求。<br>最稀缺优先（rarest first）：针对没有的块在邻居中决定最稀缺的块，首先请求那些最稀缺的块，目标是大致地均衡每个块在洪流中的副本数量。<br>对换算法：根据当前能够以最高速率向它提供数据的邻居，给出其优先权。（针对A优先响应哪个请求）</p>
<h3 id="分布式散列表"><a href="#分布式散列表" class="headerlink" title="分布式散列表"></a>分布式散列表</h3><p>在P2P体系中，每个对等方将保持（键，值）对仅占总体的一个小子集。允许任何对等方用一个特别的键来查询该分布式数据库。分布式数据库则将定位拥有该（键，值）对的对等方，然后向查询的对等方返回该（键，值）对。任何对等方也将允许在数据库中插入新（键，值）对。这样的分布式数据库被称为分布式散列表（DHT）。<br>其中键可以是目录名，值是存储内容的IP地址。</p>
<h4 id="设计DHT的方法"><a href="#设计DHT的方法" class="headerlink" title="设计DHT的方法"></a>设计DHT的方法</h4><p>为每个对等方分配一个标识符，每个标识符是一个[0,2^n-1]范围内的整数，n取某些固定值，这样的标识符能够由n比特法表示，键也是同一范围内的整数。为其标识符最邻近该键的对等方分配一个（键，值）对。<br>最邻近： 键的最邻后继。  </p>
<h4 id="环形DHT"><a href="#环形DHT" class="headerlink" title="环形DHT"></a>环形DHT</h4><p>每个对等方仅知道它的直接后继和直接前任。<br>在最差的情况下，DHT中的所有N个节点将必须环绕转发报文，平均发送N/2条报文。<br>具有捷径的环形DHT：每个对等方不仅联系它的直接后继和直接前任，而且联系分布在环上的数量相对少的捷径对等方。DHT能被设计成每个对等方的邻居数量以及每个请求的报文数量均为O（logN）。</p>
<h4 id="对等方扰动"><a href="#对等方扰动" class="headerlink" title="对等方扰动"></a>对等方扰动</h4><p>对等方的加入和离开使得其它对等方必须更新其前任和后继</p>
<blockquote>
<p>这样全部摘要的方式虽然能较好复习书本内容，但付出的时间及精力也是巨大的，在此感谢网上无私奉献的同志们，后续不会再写这样的内容了。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/02/13/%E5%BA%94%E7%94%A8%E5%B1%82/" data-id="ckja57eei000dfq131dcgf84e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python中的元类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/26/python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB/" class="article-date">
  <time datetime="2019-01-26T07:42:49.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/26/python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB/">python中的元类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="深刻理解Python中的元类-metaclass"><a href="#深刻理解Python中的元类-metaclass" class="headerlink" title="深刻理解Python中的元类(metaclass)"></a>深刻理解Python中的元类(metaclass)</h2><blockquote>
<p>本文由 伯乐在线 - bigship 翻译<br>译注：这是一篇在Stack overflow上很热的帖子。提问者自称已经掌握了有关Python OOP编程中的各种概念，但始终觉得元类(metaclass)难以理解。他知道这肯定和自省有关，但仍然觉得不太明白，希望大家可以给出一些实际的例子和代码片段以帮助理解，以及在什么情况下需要进行元编程。于是e-satis同学给出了神一般的回复，该回复获得了985点的赞同点数，更有人评论说这段回复应该加入到Python的官方文档中去。而e-satis同学本人在Stack Overflow中的声望积分也高达64271分。以下就是这篇精彩的回复:</p>
</blockquote>
<h3 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h3><p>在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> my_object</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>
<p>但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：  </p>
<ol>
<li>将它赋值给一个变量  </li>
<li>拷贝它  </li>
<li>为它增加属性  </li>
<li>将它作为函数参数进行传递  </li>
</ol>
<p>下面是示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> ObjectCreator     <span class="comment"># 你可以打印一个类，因为它其实也是一个对象</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ObjectCreator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">def</span> <span class="title">echo</span>(<span class="params">o</span>):</span></span><br><span class="line">…       <span class="built_in">print</span> o</span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator)                 <span class="comment"># 你可以将类做为参数传给函数</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ObjectCreator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">hasattr</span>(<span class="params">ObjectCreator, <span class="string">&#x27;new_attribute&#x27;</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">Fasle</span></span></span><br><span class="line">&gt;&gt;&gt; ObjectCreator.new_attribute = &#x27;foo&#x27; #  你可以为类增加属性</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">hasattr</span>(ObjectCreator, <span class="string">&#x27;new_attribute&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> ObjectCreator.new_attribute</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># 你可以将类赋值给一个变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> ObjectCreatorMirror()</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="动态地创建类"><a href="#动态地创建类" class="headerlink" title="动态地创建类"></a>动态地创建类</h3><p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span>(<span class="params">name</span>):</span></span><br><span class="line">…       <span class="keyword">if</span> name == <span class="string">&#x27;foo&#x27;</span>:</span><br><span class="line">…           <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…               <span class="keyword">pass</span></span><br><span class="line">…           <span class="keyword">return</span> Foo     <span class="comment"># 返回的是类，不是类的实例</span></span><br><span class="line">…       <span class="keyword">else</span>:</span><br><span class="line">…           <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…               <span class="keyword">pass</span></span><br><span class="line">…           <span class="keyword">return</span> Bar</span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> MyClass              <span class="comment"># 函数返回的是类，不是类的实例</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>&#x27;.<span class="title">Foo</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">MyClass</span>()            # 你可以通过这个类创建类实例，也就是对象</span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x89c6d4c</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">type</span>(<span class="number">1</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">type</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">type</span>(ObjectCreator)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">type</span>(ObjectCreator())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ObjectCreator</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）</p>
<p>type可以像这样工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typet (类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</span><br></pre></td></tr></table></figure>
<p>比如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以手动像这样创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = <span class="built_in">type</span>(<span class="string">&#x27;MyShinyClass&#x27;</span>, (), &#123;&#125;)  <span class="comment"># 返回一个类对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> MyShinyClass</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">MyShinyClass</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">MyShinyClass</span>()  #  创建一个该类的实例</span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x8997cec</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。</p>
<p>type 接受一个字典来为类定义属性，因此</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       bar = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>可以翻译为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = <span class="built_in">type</span>(<span class="string">&#x27;Foo&#x27;</span>, (), &#123;<span class="string">&#x27;bar&#x27;</span>:<span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>并且可以将Foo当成一个普通的类一样使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> Foo</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Foo</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">Foo</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> f</span><br><span class="line">&lt;__main__.Foo <span class="built_in">object</span> at <span class="number">0x8a9b84c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> f.bar</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>当然，你可以向这个类继承，所以，如下的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FooChild</span>(<span class="params">Foo</span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>就可以写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,),&#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> FooChild</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">FooChild</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">FooChild</span>.<span class="title">bar</span>   # <span class="title">bar</span>属性是由<span class="title">Foo</span>继承而来</span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure>
<p>最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span>(<span class="params">self</span>):</span></span><br><span class="line">…       <span class="built_in">print</span> self.bar</span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,), &#123;<span class="string">&#x27;echo_bar&#x27;</span>: echo_bar&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;echo_bar&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(FooChild, <span class="string">&#x27;echo_bar&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。</p>
<h3 id="到底什么是元类（终于到主题了）"><a href="#到底什么是元类（终于到主题了）" class="headerlink" title="到底什么是元类（终于到主题了）"></a>到底什么是元类（终于到主题了）</h3><p>元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解 为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass = MetaClass()</span><br><span class="line">MyObject = MyClass()</span><br></pre></td></tr></table></figure>
<p>你已经看到了type可以让你像这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass = <span class="built_in">type</span>(<span class="string">&#x27;MyClass&#x27;</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span> <span class="keyword">pass</span></span><br><span class="line">&gt;&gt;&gt;foo.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Bar</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，对于任何一个__class__的__class__属性又是什么呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D） type就是Python的内建元类，当然了，你也可以创建自己的元类。</p>
<h3 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__属性"></a>__metaclass__属性</h3><p>你可以在写一个类的时候为其添加__metaclass__属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__metaclass__ = something…</span><br><span class="line">[…]</span><br></pre></td></tr></table></figure>
<p>如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">Bar</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>Python做了如下的操作：</p>
<p>Foo中有<strong>metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass</strong>,Python就会用内置的type来创建这个类对象。</p>
<p>现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。</p>
<h3 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h3><p>元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。</p>
<p>幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元类会自动将你通常传给‘type’的参数作为自己的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span>(<span class="params">future_class_name, future_class_parents, future_class_attr</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;返回一个类对象，将属性都转为大写形式&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#  选择所有不以&#x27;__&#x27;开头的属性</span></span><br><span class="line">    attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">     <span class="comment"># 将它们转为大写形式</span></span><br><span class="line">    uppercase_attr = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">    <span class="comment"># 通过&#x27;type&#x27;来做类对象的创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"> </span><br><span class="line">__metaclass__ = upper_attr  <span class="comment">#  这会作用到这个模块中的所有类</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中</span></span><br><span class="line">    bar = <span class="string">&#x27;bip&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出:True</span></span><br><span class="line"> </span><br><span class="line">f = Foo()</span><br><span class="line"><span class="built_in">print</span> f.BAR</span><br><span class="line"><span class="comment"># 输出:&#x27;bip&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在让我们再做一次，这一次用一个真正的class来当做元类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请记住，&#x27;type&#x27;实际上是一个类，就像&#x27;str&#x27;和&#x27;int&#x27;一样</span></span><br><span class="line"><span class="comment"># 所以，你可以从type继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="comment"># __new__ 是在__init__之前被调用的特殊方法</span></span><br><span class="line">    <span class="comment"># __new__是用来创建对象并返回之的方法</span></span><br><span class="line">    <span class="comment"># 而__init__只是用来将传入的参数初始化给对象</span></span><br><span class="line">    <span class="comment"># 你很少用到__new__，除非你希望能够控制对象的创建</span></span><br><span class="line">    <span class="comment"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span></span><br><span class="line">    <span class="comment"># 如果你希望的话，你也可以在__init__中做些事情</span></span><br><span class="line">    <span class="comment"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">upperattr_metaclass, future_class_name, future_class_parents, future_class_attr</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">        uppercase_attr = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的__new__方法。现在让我们这样去处理:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">upperattr_metaclass, future_class_name, future_class_parents, future_class_attr</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">        uppercase_attr = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 复用type.__new__方法</span></span><br><span class="line">        <span class="comment"># 这就是基本的OOP编程，没什么魔法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, bases, dct</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> dct.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>)</span><br><span class="line">        uppercase_attr  = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, bases, dct</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> dct.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">        uppercase_attr = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的：</p>
<ol>
<li>  拦截类的创建</li>
<li>  修改类</li>
<li>  返回修改之后的类</li>
</ol>
<h3 id="为什么要用metaclass类而不是函数"><a href="#为什么要用metaclass类而不是函数" class="headerlink" title="为什么要用metaclass类而不是函数?"></a>为什么要用metaclass类而不是函数?</h3><p>由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因：</p>
<ol>
<li>意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。</li>
<li>你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。</li>
<li>你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。</li>
<li>你可以使用<strong>new</strong>, __init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服些。</li>
<li>哇哦，这东西的名字是metaclass，肯定非善类，我要小心！</li>
</ol>
<h3 id="究竟为什么要使用元类？"><a href="#究竟为什么要使用元类？" class="headerlink" title="究竟为什么要使用元类？"></a>究竟为什么要使用元类？</h3><p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：</p>
<blockquote>
<p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”  —— Python界的领袖 Tim Peters</p>
</blockquote>
<p>元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    age = models.IntegerField()</span><br></pre></td></tr></table></figure>

<p>但是如果你像这样做的话：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guy  = Person(name=<span class="string">&#x27;bob&#x27;</span>, age=<span class="string">&#x27;35&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> guy.age</span><br></pre></td></tr></table></figure>
<p>这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(Foo)</span><br><span class="line"><span class="number">142630324</span></span><br></pre></td></tr></table></figure>
<p>Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：</p>
<ol>
<li>Monkey patching</li>
<li>class decorators</li>
</ol>
<p>当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/01/26/python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB/" data-id="ckja57eeh000bfq135ugb0hkc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-celery定时任务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/20/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="article-date">
  <time datetime="2019-01-20T08:22:42.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/20/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">celery定时任务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>celery实现定时任务的方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33733970/article/details/82886845">https://blog.csdn.net/qq_33733970/article/details/82886845</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/01/20/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" data-id="ckja57ee60005fq1346ms1qy0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/celery/" rel="tag">celery</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HAProxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/15/HAProxy/" class="article-date">
  <time datetime="2018-12-15T14:25:05.000Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/15/HAProxy/">HAProxy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>HAProxy是一款开源、高性能的、基于TCP和HTTP应用的负载均衡软件。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<ul>
<li>可靠性和稳定性非常好，可与硬件级的F5负载均衡设备相媲美。</li>
</ul>
</blockquote>
<ul>
<li>最高可以同时维护40000~50000个并发连接，单位时间内处理的最大请求数为20000个，最大数据处理能力可达10Gbit/s。</li>
<li>支持多于8种负载均衡算法，同时也支持会话保持。</li>
<li>支持虚拟主机功能。</li>
<li>从HAProxy1.3后开始支持连接拒绝、全透明代理等功能。</li>
<li>支持功能强大的服务器状态监控页面，可实时了解系统的运行状况。</li>
<li>拥有功能强大的ACL(访问控制列表）支持，能给使用带来很大方便。</li>
</ul>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p>下载地址：<a target="_blank" rel="noopener" href="https://fossies.org/linux/misc/haproxy-1.8.13.tar.gz/">https://fossies.org/linux/misc/haproxy-1.8.13.tar.gz/</a>  </p>
<h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><pre><code>`tar -zxvf haproxy-1.8.13.tar.gz`  
`cd haproxy-1.8.13`  </code></pre>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>`make TARGET=linux2628 ARCH=x86_64 PREFIX=/usr/local/haproxy`  
`make install PREFIX=/usr/local/haproxy`  </code></pre>
<p>安装完成后安装目录下生成三个目录<code>doc</code> <code>sbin</code> <code>share</code></p>
<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>安装完成后，默认安装目录中没有配置文件，需要在安装目录中创建配置文件目录和配置文件：<br><code>mkdir /usr/local/haproxy/conf</code><br><code>touch haproxy.cfg</code><br>#####2.1配置文件概述<br>HAProxy配置文件由5个部分组成：  </p>
<blockquote>
<ul>
<li>global部分<br>用来设置全局配置参数，属于进程级的配置，通常和操作系统配置有关。</li>
</ul>
</blockquote>
<ul>
<li>defaults部分<br>默认参数配置部分。在此部分设置的参数值，默认会自动被引用到下面的frontend、backend和listen部分中。</li>
<li>frontend部分<br>用于设置接受用户请求的前端虚拟节点。frontend可根据ACL规则直接指定要使用的后端（backend）。</li>
<li>backend部分<br>用于设置集群后端服务集群的配置，用来添加一组真实服务器。</li>
<li>listen部分<br>frontend部分和backend部分的结合体。HAProxy 1.3版本之前，HAProxy的所有配置选项都在这个部分中设置。  </li>
</ul>
<h5 id="2-2配置文件详解"><a href="#2-2配置文件详解" class="headerlink" title="2.2配置文件详解"></a>2.2配置文件详解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#########全局配置##########</span><br><span class="line">global</span><br><span class="line">　　log 127.0.0.1 local0 info #日志输出配置，所有日志都记录在本机，通过local0输出,info定义haproxy日志级别[error warring info debug]</span><br><span class="line">　　daemon #以后台形式运行harpoxy</span><br><span class="line">　　nbproc 1 #设置进程数量</span><br><span class="line">　　maxconn 4096 #默认最大连接数</span><br><span class="line">　　#user haproxy #运行haproxy的用户</span><br><span class="line">　　#group haproxy #运行haproxy的用户所在的组</span><br><span class="line">　　#pidfile &#x2F;var&#x2F;run&#x2F;haproxy.pid #haproxy进程PID文件</span><br><span class="line"></span><br><span class="line">########默认配置############</span><br><span class="line">defaults</span><br><span class="line">   log global #使用全局的日志配置，global表示引用在HAProxy配置文件global部分中定义的log选项配置格式</span><br><span class="line">　　mode http #默认的模式mode &#123; tcp|http|health &#125;，tcp是默认模式，客户端和服务器间建立全双工的连接，不对7层报文做任何类型的检查，http模式下客户端请求被转发前会被深度分析，所有与RFC格式不兼容的请求将被拒绝，health只会返回OK，基本已废弃</span><br><span class="line">　　retries 2 #设置连接后端服务器的失败重试次数，连接失败的次数如果超过设定值，HAProxy将对应的后端服务器标记为不可用</span><br><span class="line">　　maxconn 4096 #默认的最大连接数</span><br><span class="line">　　timeout connect 5000ms #成功连接到一台服务器的最长等待时间</span><br><span class="line">　　timeout client 30000ms #连接客户端发送数据时最长的等待时间</span><br><span class="line">　　timeout server 30000ms #服务器端返回客户端数据发送的最长等待时间</span><br><span class="line">　　timeout check 2000 #对后端服务器的检测超时时间</span><br><span class="line">　　#timeout http-keep-alive10s #默认持久连接超时时间</span><br><span class="line">　　#timeout http-request 10s #默认http请求超时时间</span><br><span class="line">　　#timeout queue 1m #默认队列超时时间</span><br><span class="line">　　balance roundrobin #设置默认负载均衡方式，轮询方式</span><br><span class="line">　　#balance source #设置默认负载均衡方式，类似于nginx的ip_hash</span><br><span class="line">　　#balnace leastconn #设置默认负载均衡方式，最小连接数</span><br><span class="line"></span><br><span class="line">########统计页面配置########</span><br><span class="line">listen admin_stats   #定义了一个名为“admin_stats”的实例</span><br><span class="line">　　bind 0.0.0.0:1080 #设置Frontend和Backend的组合体，监控组的名称，按需要自定义名称</span><br><span class="line">　　mode http</span><br><span class="line">　　option httplog #采用http日志格式</span><br><span class="line">　　#log 127.0.0.1 local0 err #错误日志记录</span><br><span class="line">　　maxconn 10 #默认的最大连接数</span><br><span class="line">　　stats refresh 30s #统计页面自动刷新时间</span><br><span class="line">　　stats uri &#x2F;stats #统计页面url</span><br><span class="line">　　stats realm welcome login\ Haproxy #登录统计页面时密码框上提示文本</span><br><span class="line">　　stats auth admin:admin #设置监控页面的用户和密码:admin,可以设置多个用户名</span><br><span class="line">　　stats hide-version #隐藏统计页面上HAProxy的版本信息</span><br><span class="line">　　stats admin if TRUE #设置手工启动&#x2F;禁用后端服务器，后端服务器(haproxy-1.4.9以后版本)</span><br><span class="line"></span><br><span class="line">########设置haproxy 错误页面#####</span><br><span class="line">#errorfile 403 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;403.http</span><br><span class="line">#errorfile 500 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;500.http</span><br><span class="line">#errorfile 502 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;502.http</span><br><span class="line">#errorfile 503 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;503.http</span><br><span class="line">#errorfile 504 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;504.http</span><br><span class="line"></span><br><span class="line">########frontend前端配置##############</span><br><span class="line">frontend main   #定义了一个名为“main”的前端虚拟节点</span><br><span class="line">　　bind *:80 #定义一个或几个监听的套接字</span><br><span class="line">　　acl web hdr(host) -i www.abc.com  #acl后面是规则名称，-i为忽略大小写，后面跟的是要访问的域名，如果访问www.abc.com这个域名，就触发web规则</span><br><span class="line">　　acl img hdr(host) -i img.abc.com  #如果访问img.abc.com这个域名，就触发img规则</span><br><span class="line">　　use_backend webserver if web   #如果上面定义的web规则被触发，即访问www.abc.com，就将请求分发到webserver这个作用域</span><br><span class="line">　　use_backend imgserver if img   #如果上面定义的img规则被触发，即访问img.abc.com，就将请求分发到imgserver这个作用域</span><br><span class="line">　　default_backend dynamic #指定默认的后端服务池，dynamic在backend部分定义，不满足则响应backend的默认页面</span><br><span class="line"></span><br><span class="line">########backend后端配置##############</span><br><span class="line">backend webserver #webserver作用域</span><br><span class="line">　　mode http</span><br><span class="line">　　balance roundrobin #balance roundrobin 负载轮询，balance source 保存session值，支持static-rr，leastconn，first，uri等参数</span><br><span class="line">　　option httpchk &#x2F;index.html HTTP&#x2F;1.0 #健康检查, 检测文件，如果分发到后台index.html访问不到就不再分发给它</span><br><span class="line">   option redispatch #用于cookie保持的环境中，HAProxy将serverID插入cookie中，以保证会话的持久性，如果后端服务器故障，客户端的请求会被强制定向到另一个健康的服务器上</span><br><span class="line">　　server web1 10.16.0.9:8085 cookie 1 weight 5 check inter 2000 rise 2 fall 3</span><br><span class="line">　　server web2 10.16.0.10:8085 cookie 2 weight 3 check inter 2000 rise 2 fall 3</span><br><span class="line">   #定义多个后端真实服务器</span><br><span class="line">　　#cookie 1表示serverid为1，check inter 1500 是检测心跳频率</span><br><span class="line">　　#rise 2是2次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重</span><br><span class="line"></span><br><span class="line">backend imgserver  #定义后端服务池</span><br><span class="line">　　mode http</span><br><span class="line">　　option httpchk &#x2F;index.php</span><br><span class="line">　　balance roundrobin</span><br><span class="line">　　server img01 192.168.137.101:80 check inter 2000 fall 3</span><br><span class="line">　　server img02 192.168.137.102:80 check inter 2000 fall 3</span><br><span class="line"></span><br><span class="line">backend dynamic   #定义后端服务池</span><br><span class="line">　　balance roundrobin</span><br><span class="line">　　server test1 192.168.1.23:80 check maxconn 2000</span><br><span class="line">　　server test2 192.168.1.24:80 check maxconn 2000</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>####3.通过ACL规则实现智能负载均衡<br>HAProxy通过ACL完成以下两种主要功能：</p>
<blockquote>
<ol>
<li>通过设置的ACL规则检查客户端请求是否合法，如果符合ACL规则要求就放行。  </li>
<li>符合ACL规则要求的请求将被提交到后端的服务器集群，进而实现基于ACL规则的负载均衡。</li>
</ol>
</blockquote>
<p>HAProxy中的ACL规则经常使用在frontend部分中，使用方法如下：<br><code>acl 自定义的acl名称 acl方法 -i [匹配的路径或文件]</code>  </p>
<ul>
<li>acl：一个关键字，表示定义ACL规则的开始。  </li>
<li>acl方法：HAProxy定义了很多ACL方法，常用的方法有 <code>hdr_reg(host)</code>、 <code>hdr_dom(host)</code>、 <code>hdr_beg(host)</code>、 <code>url_sub</code>、 <code>url_dir</code>、 <code>path_beg</code>、 <code>path_end</code>等。  </li>
<li><code>-i</code>表示忽略大小写。</li>
</ul>
<p>####4.管理与维护HAProxy<br>HAProxy安装目录的sbin目录下有一个可执行的二进制文件<code>haproxy</code>，对HAProxy的启动、关闭、重启等操作都是通过这个二进制文件来实现的。   </p>
<p>以下即此文件的用法：<br><code>haproxy [-f &lt;cfgfile&gt;]* [ -vdVD ] [ -n &lt;maxconn&gt; ] [ -N &lt;maxpconn&gt; ]</code><br>其中：<br><code>cfgfile</code>:配置文件<br><code>maxconn</code>:最大并发连接总数<br><code>maxpconn</code>：默认的连接数  </p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-v</td>
<td align="left">显示当前版本信息；“-vv”显示已知的创建选项</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="left">表示让程序运行在debug模式：“-db”表示禁用后台模式，让程序在前台运行</td>
</tr>
<tr>
<td align="center">-D</td>
<td align="left">让程序以daemon模式启动，此选项也可以在HAProxy配置文件中设置</td>
</tr>
<tr>
<td align="center">-q</td>
<td align="left">表示无限提示模式，程序运行部输出任何信息</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="left">对HAProxy配置文件进行语法检查。若配置文件错误，会输出对应的错误位置和错误消息</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="left">设置最大并发连接总数</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="left">限制可用的内存大小，以MB为单位</td>
</tr>
<tr>
<td align="center">-N</td>
<td align="left">设置默认的连接数</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="left">设置HAProxy的PID文件路径</td>
</tr>
<tr>
<td align="center">-de</td>
<td align="left">不使用epoll模型</td>
</tr>
<tr>
<td align="center">-ds</td>
<td align="left">不使用speculative epoll</td>
</tr>
<tr>
<td align="center">-dp</td>
<td align="left">不使用poll模型</td>
</tr>
<tr>
<td align="center">-sf</td>
<td align="left">程序启动后想PID文件里的进程发送FINISH信号，这个参数需要放在命令行的最后</td>
</tr>
<tr>
<td align="center">-st</td>
<td align="left">程序启动后向PID里的进程发送TERMINATE信号，这个参数放在命令行的最后，经常用于重启HAProxy进程</td>
</tr>
</tbody></table>
<ul>
<li>启动HAProxy<br><code>/usr/local/haproxy/sbin/haproxy -f \ &gt; /usr/local/haproxy/conf/haproxy.cfg</code>  </li>
<li>关闭HAProxy<br><code>killalll -9 haproxy</code>  </li>
<li>平滑重启HAProxy<br><code>/usr/local/haproxy/sbin/haproxy -f \ &gt; /usr/local/haproxy/conf/haproxy.cfg -st &#39;cat /usr/local/haproxy/logs/haproxy.pid&#39;</code>  </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/15/HAProxy/" data-id="ckja57ee40003fq13e48g5ttg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-minio" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/15/minio/" class="article-date">
  <time datetime="2018-12-15T14:23:03.000Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/15/minio/">minio</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##分布式Minio服务  </p>
<h3 id="Minio服务的特点"><a href="#Minio服务的特点" class="headerlink" title="Minio服务的特点"></a>Minio服务的特点</h3><blockquote>
<ol>
<li>数据保护：引入纠删码来防范节点宕机和位衰减，部署分布式minio最少需要4块硬盘。</li>
<li>高可用：集群中部署了n块硬盘，当不少于n/2块硬盘在线时，存储的数据就是安全的。创建新对象需要至少n/2+1块硬盘。</li>
<li>限制：分布式minio单租户要求最少两台，最多32台服务器，但是对这些服务器中共享硬盘的个数没有限制。</li>
<li>一致性：在分布式和单机模式下，minio的读写操作都严格遵循 read-after-write 一致性原则。</li>
</ol>
</blockquote>
<h3 id="部署分布式Minio服务"><a href="#部署分布式Minio服务" class="headerlink" title="部署分布式Minio服务"></a>部署分布式Minio服务</h3><h4 id="单节点安装Minio"><a href="#单节点安装Minio" class="headerlink" title="单节点安装Minio"></a>单节点安装Minio</h4><p>分布式minio系统中每台机器都需要安装Minio（<a target="_blank" rel="noopener" href="https://docs.minio.io/docs/minio-quickstart-guide">官方文档</a>）<br>以下是安装过程（centos7-64bit)  </p>
<p><code>wget https://dl.minio.io/server/minio/release/linux-amd64/minio</code><br><code>chmod +x minio</code><br><code>./minio server /data</code><br><img src="./%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8minio.png">  </p>
<p>浏览器访问<a target="_blank" rel="noopener" href="http://127.0.0.1:9000/">http://127.0.0.1:9000</a> 或 <a target="_blank" rel="noopener" href="http://10.0.0.13:9000/">http://10.0.0.13:9000</a> ,用AccessKey和SecretKey登录，Minio界面如下图：<br><img src="./minio%E6%8E%A7%E5%88%B6%E7%95%8C%E9%9D%A2.png">  </p>
<h3 id="分布式Minio"><a href="#分布式Minio" class="headerlink" title="分布式Minio"></a>分布式Minio</h3><blockquote>
<p>注意：  </p>
</blockquote>
<ol>
<li>执行Minio命令前，先将MINIO_ACCESS_KEY和MINIO_SECRET_KEY在所有节点上export到环境变量；  </li>
<li>所有运行Minio的节点需要在相同的环境下，即相同的操作系统和相同数量的硬盘；  </li>
<li>分布式Minio需要使用空目录；  </li>
<li>运行分布式Minio的服务器的节点时间差不能超过3秒，可以使用<a target="_blank" rel="noopener" href="http://www.ntp.org/">NTP</a>来保证服务器间的时间一致性。  </li>
</ol>
<p>用来运行minio服务的三台机器分别为20.20.20.152, 20.20.20.153, 20.20.20.155，这三台机器都安装了minio，以下的操作需要分别在三台机器上执行（<a target="_blank" rel="noopener" href="https://docs.minio.io/docs/distributed-minio-quickstart-guide">官方文档</a>）：  </p>
<ol>
<li><p>创建存储路径<br><code>mkdir /export&#123;1,2,3,4&#125;</code>  </p>
</li>
<li><p>开放80和9000端口<br><code>firewall-cmd --add-port=80/tcp --permanent</code><br><code>firewall-cmd --add-port=9000/tcp --permanent</code><br><code>firewall-cmd --reload</code>    </p>
</li>
<li><p>设置环境变量access_key和secret_key<br><code>export MINIO_ACCESS_KEY=ruchi</code><br><code>export MINIO_SECRET_KEY=miniocluster</code>  </p>
</li>
<li><p>启动服务<br><code>./minio server http://20.20.20.&#123;152,153,155&#125;/export&#123;1,2,3,4&#125;</code><br><img src="./%E5%90%AF%E5%8A%A8minio%E9%9B%86%E7%BE%A4.png">  </p>
</li>
<li><p>后台运行服务(可选）<br><code>./minio server http://20.20.20.&#123;152,153,155&#125;/export&#123;1,2,3,4&#125; &gt; minio.file 2&gt;&amp;1 &amp;</code>  </p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/15/minio/" data-id="ckja57ee70006fq13gibk50jj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/08/hello-world/" class="article-date">
  <time datetime="2018-12-08T13:42:10.000Z" itemprop="datePublished">2018-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/08/hello-world/" data-id="ckhuo71pg0000ai137dpx5o58" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/celery/" rel="tag">celery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 16.67px;">C#</a> <a href="/tags/celery/" style="font-size: 10px;">celery</a> <a href="/tags/docker/" style="font-size: 16.67px;">docker</a> <a href="/tags/linux/" style="font-size: 16.67px;">linux</a> <a href="/tags/python/" style="font-size: 13.33px;">python</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/tool/" style="font-size: 13.33px;">tool</a> <a href="/tags/web/" style="font-size: 16.67px;">web</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 10px;">安全</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 16.67px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/17/LeetCode-1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/">LeetCode-1232. 缀点成线</a>
          </li>
        
          <li>
            <a href="/2021/01/17/LeetCode-803-%E6%89%93%E7%A0%96%E5%9D%97/">LeetCode-803.打砖块</a>
          </li>
        
          <li>
            <a href="/2021/01/15/LeetCode-947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/">LeetCode-947. 移除最多的同行或同列石头</a>
          </li>
        
          <li>
            <a href="/2021/01/15/python%E7%9A%84collections%E5%92%8Citertools/">python的collections和itertools</a>
          </li>
        
          <li>
            <a href="/2021/01/14/LeetCode-%E5%8F%AF%E8%A2%AB-5-%E6%95%B4%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%80/">LeetCode-可被 5 整除的二进制前缀</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 IMTE<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>