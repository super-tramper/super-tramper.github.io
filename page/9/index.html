<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>IMTE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="IMTE">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="IMTE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="IMTE">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="IMTE" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">IMTE</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-python中的元类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/26/python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB/" class="article-date">
  <time datetime="2019-01-26T07:42:49.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/26/python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB/">python中的元类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="深刻理解Python中的元类-metaclass"><a href="#深刻理解Python中的元类-metaclass" class="headerlink" title="深刻理解Python中的元类(metaclass)"></a>深刻理解Python中的元类(metaclass)</h2><blockquote>
<p>本文由 伯乐在线 - bigship 翻译<br>译注：这是一篇在Stack overflow上很热的帖子。提问者自称已经掌握了有关Python OOP编程中的各种概念，但始终觉得元类(metaclass)难以理解。他知道这肯定和自省有关，但仍然觉得不太明白，希望大家可以给出一些实际的例子和代码片段以帮助理解，以及在什么情况下需要进行元编程。于是e-satis同学给出了神一般的回复，该回复获得了985点的赞同点数，更有人评论说这段回复应该加入到Python的官方文档中去。而e-satis同学本人在Stack Overflow中的声望积分也高达64271分。以下就是这篇精彩的回复:</p>
</blockquote>
<h3 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h3><p>在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> my_object</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>
<p>但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：  </p>
<ol>
<li>将它赋值给一个变量  </li>
<li>拷贝它  </li>
<li>为它增加属性  </li>
<li>将它作为函数参数进行传递  </li>
</ol>
<p>下面是示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> ObjectCreator     <span class="comment"># 你可以打印一个类，因为它其实也是一个对象</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ObjectCreator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">def</span> <span class="title">echo</span>(<span class="params">o</span>):</span></span><br><span class="line">…       <span class="built_in">print</span> o</span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator)                 <span class="comment"># 你可以将类做为参数传给函数</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ObjectCreator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">hasattr</span>(<span class="params">ObjectCreator, <span class="string">&#x27;new_attribute&#x27;</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">Fasle</span></span></span><br><span class="line">&gt;&gt;&gt; ObjectCreator.new_attribute = &#x27;foo&#x27; #  你可以为类增加属性</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">hasattr</span>(ObjectCreator, <span class="string">&#x27;new_attribute&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> ObjectCreator.new_attribute</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># 你可以将类赋值给一个变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> ObjectCreatorMirror()</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="动态地创建类"><a href="#动态地创建类" class="headerlink" title="动态地创建类"></a>动态地创建类</h3><p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span>(<span class="params">name</span>):</span></span><br><span class="line">…       <span class="keyword">if</span> name == <span class="string">&#x27;foo&#x27;</span>:</span><br><span class="line">…           <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…               <span class="keyword">pass</span></span><br><span class="line">…           <span class="keyword">return</span> Foo     <span class="comment"># 返回的是类，不是类的实例</span></span><br><span class="line">…       <span class="keyword">else</span>:</span><br><span class="line">…           <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…               <span class="keyword">pass</span></span><br><span class="line">…           <span class="keyword">return</span> Bar</span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> MyClass              <span class="comment"># 函数返回的是类，不是类的实例</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>&#x27;.<span class="title">Foo</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">MyClass</span>()            # 你可以通过这个类创建类实例，也就是对象</span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x89c6d4c</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">type</span>(<span class="number">1</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">type</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">type</span>(ObjectCreator)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">type</span>(ObjectCreator())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ObjectCreator</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）</p>
<p>type可以像这样工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typet (类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</span><br></pre></td></tr></table></figure>
<p>比如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以手动像这样创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = <span class="built_in">type</span>(<span class="string">&#x27;MyShinyClass&#x27;</span>, (), &#123;&#125;)  <span class="comment"># 返回一个类对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> MyShinyClass</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">MyShinyClass</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">MyShinyClass</span>()  #  创建一个该类的实例</span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x8997cec</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。</p>
<p>type 接受一个字典来为类定义属性，因此</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       bar = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>可以翻译为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = <span class="built_in">type</span>(<span class="string">&#x27;Foo&#x27;</span>, (), &#123;<span class="string">&#x27;bar&#x27;</span>:<span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>并且可以将Foo当成一个普通的类一样使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> Foo</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Foo</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">Foo</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> f</span><br><span class="line">&lt;__main__.Foo <span class="built_in">object</span> at <span class="number">0x8a9b84c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> f.bar</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>当然，你可以向这个类继承，所以，如下的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FooChild</span>(<span class="params">Foo</span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>就可以写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,),&#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> FooChild</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">FooChild</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span> <span class="title">FooChild</span>.<span class="title">bar</span>   # <span class="title">bar</span>属性是由<span class="title">Foo</span>继承而来</span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure>
<p>最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span>(<span class="params">self</span>):</span></span><br><span class="line">…       <span class="built_in">print</span> self.bar</span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,), &#123;<span class="string">&#x27;echo_bar&#x27;</span>: echo_bar&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;echo_bar&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(FooChild, <span class="string">&#x27;echo_bar&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。</p>
<h3 id="到底什么是元类（终于到主题了）"><a href="#到底什么是元类（终于到主题了）" class="headerlink" title="到底什么是元类（终于到主题了）"></a>到底什么是元类（终于到主题了）</h3><p>元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解 为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass = MetaClass()</span><br><span class="line">MyObject = MyClass()</span><br></pre></td></tr></table></figure>
<p>你已经看到了type可以让你像这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass = <span class="built_in">type</span>(<span class="string">&#x27;MyClass&#x27;</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span> <span class="keyword">pass</span></span><br><span class="line">&gt;&gt;&gt;foo.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Bar</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，对于任何一个__class__的__class__属性又是什么呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D） type就是Python的内建元类，当然了，你也可以创建自己的元类。</p>
<h3 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__属性"></a>__metaclass__属性</h3><p>你可以在写一个类的时候为其添加__metaclass__属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__metaclass__ = something…</span><br><span class="line">[…]</span><br></pre></td></tr></table></figure>
<p>如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">Bar</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>Python做了如下的操作：</p>
<p>Foo中有<strong>metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass</strong>,Python就会用内置的type来创建这个类对象。</p>
<p>现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。</p>
<h3 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h3><p>元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。</p>
<p>幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元类会自动将你通常传给‘type’的参数作为自己的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span>(<span class="params">future_class_name, future_class_parents, future_class_attr</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;返回一个类对象，将属性都转为大写形式&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#  选择所有不以&#x27;__&#x27;开头的属性</span></span><br><span class="line">    attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">     <span class="comment"># 将它们转为大写形式</span></span><br><span class="line">    uppercase_attr = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">    <span class="comment"># 通过&#x27;type&#x27;来做类对象的创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"> </span><br><span class="line">__metaclass__ = upper_attr  <span class="comment">#  这会作用到这个模块中的所有类</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中</span></span><br><span class="line">    bar = <span class="string">&#x27;bip&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出:True</span></span><br><span class="line"> </span><br><span class="line">f = Foo()</span><br><span class="line"><span class="built_in">print</span> f.BAR</span><br><span class="line"><span class="comment"># 输出:&#x27;bip&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在让我们再做一次，这一次用一个真正的class来当做元类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请记住，&#x27;type&#x27;实际上是一个类，就像&#x27;str&#x27;和&#x27;int&#x27;一样</span></span><br><span class="line"><span class="comment"># 所以，你可以从type继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="comment"># __new__ 是在__init__之前被调用的特殊方法</span></span><br><span class="line">    <span class="comment"># __new__是用来创建对象并返回之的方法</span></span><br><span class="line">    <span class="comment"># 而__init__只是用来将传入的参数初始化给对象</span></span><br><span class="line">    <span class="comment"># 你很少用到__new__，除非你希望能够控制对象的创建</span></span><br><span class="line">    <span class="comment"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span></span><br><span class="line">    <span class="comment"># 如果你希望的话，你也可以在__init__中做些事情</span></span><br><span class="line">    <span class="comment"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">upperattr_metaclass, future_class_name, future_class_parents, future_class_attr</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">        uppercase_attr = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的__new__方法。现在让我们这样去处理:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">upperattr_metaclass, future_class_name, future_class_parents, future_class_attr</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">        uppercase_attr = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 复用type.__new__方法</span></span><br><span class="line">        <span class="comment"># 这就是基本的OOP编程，没什么魔法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, bases, dct</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> dct.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>)</span><br><span class="line">        uppercase_attr  = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, bases, dct</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> dct.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">        uppercase_attr = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的：</p>
<ol>
<li>  拦截类的创建</li>
<li>  修改类</li>
<li>  返回修改之后的类</li>
</ol>
<h3 id="为什么要用metaclass类而不是函数"><a href="#为什么要用metaclass类而不是函数" class="headerlink" title="为什么要用metaclass类而不是函数?"></a>为什么要用metaclass类而不是函数?</h3><p>由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因：</p>
<ol>
<li>意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。</li>
<li>你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。</li>
<li>你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。</li>
<li>你可以使用<strong>new</strong>, __init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服些。</li>
<li>哇哦，这东西的名字是metaclass，肯定非善类，我要小心！</li>
</ol>
<h3 id="究竟为什么要使用元类？"><a href="#究竟为什么要使用元类？" class="headerlink" title="究竟为什么要使用元类？"></a>究竟为什么要使用元类？</h3><p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：</p>
<blockquote>
<p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”  —— Python界的领袖 Tim Peters</p>
</blockquote>
<p>元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    age = models.IntegerField()</span><br></pre></td></tr></table></figure>

<p>但是如果你像这样做的话：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guy  = Person(name=<span class="string">&#x27;bob&#x27;</span>, age=<span class="string">&#x27;35&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> guy.age</span><br></pre></td></tr></table></figure>
<p>这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(Foo)</span><br><span class="line"><span class="number">142630324</span></span><br></pre></td></tr></table></figure>
<p>Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：</p>
<ol>
<li>Monkey patching</li>
<li>class decorators</li>
</ol>
<p>当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/01/26/python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB/" data-id="ckja57eeh000bfq135ugb0hkc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-celery定时任务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/20/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="article-date">
  <time datetime="2019-01-20T08:22:42.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/20/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">celery定时任务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>celery实现定时任务的方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33733970/article/details/82886845">https://blog.csdn.net/qq_33733970/article/details/82886845</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/01/20/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" data-id="ckja57ee60005fq1346ms1qy0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/celery/" rel="tag">celery</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HAProxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/15/HAProxy/" class="article-date">
  <time datetime="2018-12-15T14:25:05.000Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/15/HAProxy/">HAProxy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>HAProxy是一款开源、高性能的、基于TCP和HTTP应用的负载均衡软件。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<ul>
<li>可靠性和稳定性非常好，可与硬件级的F5负载均衡设备相媲美。</li>
</ul>
</blockquote>
<ul>
<li>最高可以同时维护40000~50000个并发连接，单位时间内处理的最大请求数为20000个，最大数据处理能力可达10Gbit/s。</li>
<li>支持多于8种负载均衡算法，同时也支持会话保持。</li>
<li>支持虚拟主机功能。</li>
<li>从HAProxy1.3后开始支持连接拒绝、全透明代理等功能。</li>
<li>支持功能强大的服务器状态监控页面，可实时了解系统的运行状况。</li>
<li>拥有功能强大的ACL(访问控制列表）支持，能给使用带来很大方便。</li>
</ul>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p>下载地址：<a target="_blank" rel="noopener" href="https://fossies.org/linux/misc/haproxy-1.8.13.tar.gz/">https://fossies.org/linux/misc/haproxy-1.8.13.tar.gz/</a>  </p>
<h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><pre><code>`tar -zxvf haproxy-1.8.13.tar.gz`  
`cd haproxy-1.8.13`  </code></pre>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>`make TARGET=linux2628 ARCH=x86_64 PREFIX=/usr/local/haproxy`  
`make install PREFIX=/usr/local/haproxy`  </code></pre>
<p>安装完成后安装目录下生成三个目录<code>doc</code> <code>sbin</code> <code>share</code></p>
<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>安装完成后，默认安装目录中没有配置文件，需要在安装目录中创建配置文件目录和配置文件：<br><code>mkdir /usr/local/haproxy/conf</code><br><code>touch haproxy.cfg</code><br>#####2.1配置文件概述<br>HAProxy配置文件由5个部分组成：  </p>
<blockquote>
<ul>
<li>global部分<br>用来设置全局配置参数，属于进程级的配置，通常和操作系统配置有关。</li>
</ul>
</blockquote>
<ul>
<li>defaults部分<br>默认参数配置部分。在此部分设置的参数值，默认会自动被引用到下面的frontend、backend和listen部分中。</li>
<li>frontend部分<br>用于设置接受用户请求的前端虚拟节点。frontend可根据ACL规则直接指定要使用的后端（backend）。</li>
<li>backend部分<br>用于设置集群后端服务集群的配置，用来添加一组真实服务器。</li>
<li>listen部分<br>frontend部分和backend部分的结合体。HAProxy 1.3版本之前，HAProxy的所有配置选项都在这个部分中设置。  </li>
</ul>
<h5 id="2-2配置文件详解"><a href="#2-2配置文件详解" class="headerlink" title="2.2配置文件详解"></a>2.2配置文件详解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#########全局配置##########</span><br><span class="line">global</span><br><span class="line">　　log 127.0.0.1 local0 info #日志输出配置，所有日志都记录在本机，通过local0输出,info定义haproxy日志级别[error warring info debug]</span><br><span class="line">　　daemon #以后台形式运行harpoxy</span><br><span class="line">　　nbproc 1 #设置进程数量</span><br><span class="line">　　maxconn 4096 #默认最大连接数</span><br><span class="line">　　#user haproxy #运行haproxy的用户</span><br><span class="line">　　#group haproxy #运行haproxy的用户所在的组</span><br><span class="line">　　#pidfile &#x2F;var&#x2F;run&#x2F;haproxy.pid #haproxy进程PID文件</span><br><span class="line"></span><br><span class="line">########默认配置############</span><br><span class="line">defaults</span><br><span class="line">   log global #使用全局的日志配置，global表示引用在HAProxy配置文件global部分中定义的log选项配置格式</span><br><span class="line">　　mode http #默认的模式mode &#123; tcp|http|health &#125;，tcp是默认模式，客户端和服务器间建立全双工的连接，不对7层报文做任何类型的检查，http模式下客户端请求被转发前会被深度分析，所有与RFC格式不兼容的请求将被拒绝，health只会返回OK，基本已废弃</span><br><span class="line">　　retries 2 #设置连接后端服务器的失败重试次数，连接失败的次数如果超过设定值，HAProxy将对应的后端服务器标记为不可用</span><br><span class="line">　　maxconn 4096 #默认的最大连接数</span><br><span class="line">　　timeout connect 5000ms #成功连接到一台服务器的最长等待时间</span><br><span class="line">　　timeout client 30000ms #连接客户端发送数据时最长的等待时间</span><br><span class="line">　　timeout server 30000ms #服务器端返回客户端数据发送的最长等待时间</span><br><span class="line">　　timeout check 2000 #对后端服务器的检测超时时间</span><br><span class="line">　　#timeout http-keep-alive10s #默认持久连接超时时间</span><br><span class="line">　　#timeout http-request 10s #默认http请求超时时间</span><br><span class="line">　　#timeout queue 1m #默认队列超时时间</span><br><span class="line">　　balance roundrobin #设置默认负载均衡方式，轮询方式</span><br><span class="line">　　#balance source #设置默认负载均衡方式，类似于nginx的ip_hash</span><br><span class="line">　　#balnace leastconn #设置默认负载均衡方式，最小连接数</span><br><span class="line"></span><br><span class="line">########统计页面配置########</span><br><span class="line">listen admin_stats   #定义了一个名为“admin_stats”的实例</span><br><span class="line">　　bind 0.0.0.0:1080 #设置Frontend和Backend的组合体，监控组的名称，按需要自定义名称</span><br><span class="line">　　mode http</span><br><span class="line">　　option httplog #采用http日志格式</span><br><span class="line">　　#log 127.0.0.1 local0 err #错误日志记录</span><br><span class="line">　　maxconn 10 #默认的最大连接数</span><br><span class="line">　　stats refresh 30s #统计页面自动刷新时间</span><br><span class="line">　　stats uri &#x2F;stats #统计页面url</span><br><span class="line">　　stats realm welcome login\ Haproxy #登录统计页面时密码框上提示文本</span><br><span class="line">　　stats auth admin:admin #设置监控页面的用户和密码:admin,可以设置多个用户名</span><br><span class="line">　　stats hide-version #隐藏统计页面上HAProxy的版本信息</span><br><span class="line">　　stats admin if TRUE #设置手工启动&#x2F;禁用后端服务器，后端服务器(haproxy-1.4.9以后版本)</span><br><span class="line"></span><br><span class="line">########设置haproxy 错误页面#####</span><br><span class="line">#errorfile 403 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;403.http</span><br><span class="line">#errorfile 500 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;500.http</span><br><span class="line">#errorfile 502 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;502.http</span><br><span class="line">#errorfile 503 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;503.http</span><br><span class="line">#errorfile 504 &#x2F;home&#x2F;haproxy&#x2F;haproxy&#x2F;errorfiles&#x2F;504.http</span><br><span class="line"></span><br><span class="line">########frontend前端配置##############</span><br><span class="line">frontend main   #定义了一个名为“main”的前端虚拟节点</span><br><span class="line">　　bind *:80 #定义一个或几个监听的套接字</span><br><span class="line">　　acl web hdr(host) -i www.abc.com  #acl后面是规则名称，-i为忽略大小写，后面跟的是要访问的域名，如果访问www.abc.com这个域名，就触发web规则</span><br><span class="line">　　acl img hdr(host) -i img.abc.com  #如果访问img.abc.com这个域名，就触发img规则</span><br><span class="line">　　use_backend webserver if web   #如果上面定义的web规则被触发，即访问www.abc.com，就将请求分发到webserver这个作用域</span><br><span class="line">　　use_backend imgserver if img   #如果上面定义的img规则被触发，即访问img.abc.com，就将请求分发到imgserver这个作用域</span><br><span class="line">　　default_backend dynamic #指定默认的后端服务池，dynamic在backend部分定义，不满足则响应backend的默认页面</span><br><span class="line"></span><br><span class="line">########backend后端配置##############</span><br><span class="line">backend webserver #webserver作用域</span><br><span class="line">　　mode http</span><br><span class="line">　　balance roundrobin #balance roundrobin 负载轮询，balance source 保存session值，支持static-rr，leastconn，first，uri等参数</span><br><span class="line">　　option httpchk &#x2F;index.html HTTP&#x2F;1.0 #健康检查, 检测文件，如果分发到后台index.html访问不到就不再分发给它</span><br><span class="line">   option redispatch #用于cookie保持的环境中，HAProxy将serverID插入cookie中，以保证会话的持久性，如果后端服务器故障，客户端的请求会被强制定向到另一个健康的服务器上</span><br><span class="line">　　server web1 10.16.0.9:8085 cookie 1 weight 5 check inter 2000 rise 2 fall 3</span><br><span class="line">　　server web2 10.16.0.10:8085 cookie 2 weight 3 check inter 2000 rise 2 fall 3</span><br><span class="line">   #定义多个后端真实服务器</span><br><span class="line">　　#cookie 1表示serverid为1，check inter 1500 是检测心跳频率</span><br><span class="line">　　#rise 2是2次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重</span><br><span class="line"></span><br><span class="line">backend imgserver  #定义后端服务池</span><br><span class="line">　　mode http</span><br><span class="line">　　option httpchk &#x2F;index.php</span><br><span class="line">　　balance roundrobin</span><br><span class="line">　　server img01 192.168.137.101:80 check inter 2000 fall 3</span><br><span class="line">　　server img02 192.168.137.102:80 check inter 2000 fall 3</span><br><span class="line"></span><br><span class="line">backend dynamic   #定义后端服务池</span><br><span class="line">　　balance roundrobin</span><br><span class="line">　　server test1 192.168.1.23:80 check maxconn 2000</span><br><span class="line">　　server test2 192.168.1.24:80 check maxconn 2000</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>####3.通过ACL规则实现智能负载均衡<br>HAProxy通过ACL完成以下两种主要功能：</p>
<blockquote>
<ol>
<li>通过设置的ACL规则检查客户端请求是否合法，如果符合ACL规则要求就放行。  </li>
<li>符合ACL规则要求的请求将被提交到后端的服务器集群，进而实现基于ACL规则的负载均衡。</li>
</ol>
</blockquote>
<p>HAProxy中的ACL规则经常使用在frontend部分中，使用方法如下：<br><code>acl 自定义的acl名称 acl方法 -i [匹配的路径或文件]</code>  </p>
<ul>
<li>acl：一个关键字，表示定义ACL规则的开始。  </li>
<li>acl方法：HAProxy定义了很多ACL方法，常用的方法有 <code>hdr_reg(host)</code>、 <code>hdr_dom(host)</code>、 <code>hdr_beg(host)</code>、 <code>url_sub</code>、 <code>url_dir</code>、 <code>path_beg</code>、 <code>path_end</code>等。  </li>
<li><code>-i</code>表示忽略大小写。</li>
</ul>
<p>####4.管理与维护HAProxy<br>HAProxy安装目录的sbin目录下有一个可执行的二进制文件<code>haproxy</code>，对HAProxy的启动、关闭、重启等操作都是通过这个二进制文件来实现的。   </p>
<p>以下即此文件的用法：<br><code>haproxy [-f &lt;cfgfile&gt;]* [ -vdVD ] [ -n &lt;maxconn&gt; ] [ -N &lt;maxpconn&gt; ]</code><br>其中：<br><code>cfgfile</code>:配置文件<br><code>maxconn</code>:最大并发连接总数<br><code>maxpconn</code>：默认的连接数  </p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-v</td>
<td align="left">显示当前版本信息；“-vv”显示已知的创建选项</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="left">表示让程序运行在debug模式：“-db”表示禁用后台模式，让程序在前台运行</td>
</tr>
<tr>
<td align="center">-D</td>
<td align="left">让程序以daemon模式启动，此选项也可以在HAProxy配置文件中设置</td>
</tr>
<tr>
<td align="center">-q</td>
<td align="left">表示无限提示模式，程序运行部输出任何信息</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="left">对HAProxy配置文件进行语法检查。若配置文件错误，会输出对应的错误位置和错误消息</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="left">设置最大并发连接总数</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="left">限制可用的内存大小，以MB为单位</td>
</tr>
<tr>
<td align="center">-N</td>
<td align="left">设置默认的连接数</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="left">设置HAProxy的PID文件路径</td>
</tr>
<tr>
<td align="center">-de</td>
<td align="left">不使用epoll模型</td>
</tr>
<tr>
<td align="center">-ds</td>
<td align="left">不使用speculative epoll</td>
</tr>
<tr>
<td align="center">-dp</td>
<td align="left">不使用poll模型</td>
</tr>
<tr>
<td align="center">-sf</td>
<td align="left">程序启动后想PID文件里的进程发送FINISH信号，这个参数需要放在命令行的最后</td>
</tr>
<tr>
<td align="center">-st</td>
<td align="left">程序启动后向PID里的进程发送TERMINATE信号，这个参数放在命令行的最后，经常用于重启HAProxy进程</td>
</tr>
</tbody></table>
<ul>
<li>启动HAProxy<br><code>/usr/local/haproxy/sbin/haproxy -f \ &gt; /usr/local/haproxy/conf/haproxy.cfg</code>  </li>
<li>关闭HAProxy<br><code>killalll -9 haproxy</code>  </li>
<li>平滑重启HAProxy<br><code>/usr/local/haproxy/sbin/haproxy -f \ &gt; /usr/local/haproxy/conf/haproxy.cfg -st &#39;cat /usr/local/haproxy/logs/haproxy.pid&#39;</code>  </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/15/HAProxy/" data-id="ckja57ee40003fq13e48g5ttg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-minio" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/15/minio/" class="article-date">
  <time datetime="2018-12-15T14:23:03.000Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/15/minio/">minio</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##分布式Minio服务  </p>
<h3 id="Minio服务的特点"><a href="#Minio服务的特点" class="headerlink" title="Minio服务的特点"></a>Minio服务的特点</h3><blockquote>
<ol>
<li>数据保护：引入纠删码来防范节点宕机和位衰减，部署分布式minio最少需要4块硬盘。</li>
<li>高可用：集群中部署了n块硬盘，当不少于n/2块硬盘在线时，存储的数据就是安全的。创建新对象需要至少n/2+1块硬盘。</li>
<li>限制：分布式minio单租户要求最少两台，最多32台服务器，但是对这些服务器中共享硬盘的个数没有限制。</li>
<li>一致性：在分布式和单机模式下，minio的读写操作都严格遵循 read-after-write 一致性原则。</li>
</ol>
</blockquote>
<h3 id="部署分布式Minio服务"><a href="#部署分布式Minio服务" class="headerlink" title="部署分布式Minio服务"></a>部署分布式Minio服务</h3><h4 id="单节点安装Minio"><a href="#单节点安装Minio" class="headerlink" title="单节点安装Minio"></a>单节点安装Minio</h4><p>分布式minio系统中每台机器都需要安装Minio（<a target="_blank" rel="noopener" href="https://docs.minio.io/docs/minio-quickstart-guide">官方文档</a>）<br>以下是安装过程（centos7-64bit)  </p>
<p><code>wget https://dl.minio.io/server/minio/release/linux-amd64/minio</code><br><code>chmod +x minio</code><br><code>./minio server /data</code><br><img src="./%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8minio.png">  </p>
<p>浏览器访问<a target="_blank" rel="noopener" href="http://127.0.0.1:9000/">http://127.0.0.1:9000</a> 或 <a target="_blank" rel="noopener" href="http://10.0.0.13:9000/">http://10.0.0.13:9000</a> ,用AccessKey和SecretKey登录，Minio界面如下图：<br><img src="./minio%E6%8E%A7%E5%88%B6%E7%95%8C%E9%9D%A2.png">  </p>
<h3 id="分布式Minio"><a href="#分布式Minio" class="headerlink" title="分布式Minio"></a>分布式Minio</h3><blockquote>
<p>注意：  </p>
</blockquote>
<ol>
<li>执行Minio命令前，先将MINIO_ACCESS_KEY和MINIO_SECRET_KEY在所有节点上export到环境变量；  </li>
<li>所有运行Minio的节点需要在相同的环境下，即相同的操作系统和相同数量的硬盘；  </li>
<li>分布式Minio需要使用空目录；  </li>
<li>运行分布式Minio的服务器的节点时间差不能超过3秒，可以使用<a target="_blank" rel="noopener" href="http://www.ntp.org/">NTP</a>来保证服务器间的时间一致性。  </li>
</ol>
<p>用来运行minio服务的三台机器分别为20.20.20.152, 20.20.20.153, 20.20.20.155，这三台机器都安装了minio，以下的操作需要分别在三台机器上执行（<a target="_blank" rel="noopener" href="https://docs.minio.io/docs/distributed-minio-quickstart-guide">官方文档</a>）：  </p>
<ol>
<li><p>创建存储路径<br><code>mkdir /export&#123;1,2,3,4&#125;</code>  </p>
</li>
<li><p>开放80和9000端口<br><code>firewall-cmd --add-port=80/tcp --permanent</code><br><code>firewall-cmd --add-port=9000/tcp --permanent</code><br><code>firewall-cmd --reload</code>    </p>
</li>
<li><p>设置环境变量access_key和secret_key<br><code>export MINIO_ACCESS_KEY=ruchi</code><br><code>export MINIO_SECRET_KEY=miniocluster</code>  </p>
</li>
<li><p>启动服务<br><code>./minio server http://20.20.20.&#123;152,153,155&#125;/export&#123;1,2,3,4&#125;</code><br><img src="./%E5%90%AF%E5%8A%A8minio%E9%9B%86%E7%BE%A4.png">  </p>
</li>
<li><p>后台运行服务(可选）<br><code>./minio server http://20.20.20.&#123;152,153,155&#125;/export&#123;1,2,3,4&#125; &gt; minio.file 2&gt;&amp;1 &amp;</code>  </p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/15/minio/" data-id="ckja57ee70006fq13gibk50jj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/08/hello-world/" class="article-date">
  <time datetime="2018-12-08T13:42:10.000Z" itemprop="datePublished">2018-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/08/hello-world/" data-id="ckhuo71pg0000ai137dpx5o58" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/celery/" rel="tag">celery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" rel="tag">背包问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/celery/" style="font-size: 10px;">celery</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/python/" style="font-size: 12.5px;">python</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/tool/" style="font-size: 12.5px;">tool</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 10px;">安全</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" style="font-size: 17.5px;">背包问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/02/LeetCode-424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/">LeetCode-424. 替换后的最长重复字符</a>
          </li>
        
          <li>
            <a href="/2021/02/01/LeetCode-888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2/">LeetCode-888. 公平的糖果棒交换</a>
          </li>
        
          <li>
            <a href="/2021/01/31/LeetCode-839-%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/">LeetCode-839. 相似字符串组</a>
          </li>
        
          <li>
            <a href="/2021/01/30/LeetCode-778-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/">LeetCode-778. 水位上升的泳池中游泳</a>
          </li>
        
          <li>
            <a href="/2021/01/28/LeetCode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/">LeetCode-724. 寻找数组的中心索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 IMTE<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>