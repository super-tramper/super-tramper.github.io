<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>运输层 | IMTE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="运输层运输层位于应用层和网络层之间，为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。 概述和运输层服务运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信，即不同主机上的进程能彼此发送报文而无需考虑承载这些报文的物理基础的细节。   端系统实现运输层协议，而非路由器。在发送端，运输层将从应用程序进程接收到的把稳转换成运输层分组（即运输层报文段）并向目的地发送；在接收端，网络层">
<meta property="og:type" content="article">
<meta property="og:title" content="运输层">
<meta property="og:url" content="http://example.com/2019/03/02/%E8%BF%90%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="IMTE">
<meta property="og:description" content="运输层运输层位于应用层和网络层之间，为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。 概述和运输层服务运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信，即不同主机上的进程能彼此发送报文而无需考虑承载这些报文的物理基础的细节。   端系统实现运输层协议，而非路由器。在发送端，运输层将从应用程序进程接收到的把稳转换成运输层分组（即运输层报文段）并向目的地发送；在接收端，网络层">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-03-02T10:25:33.000Z">
<meta property="article:modified_time" content="2019-03-05T14:38:00.000Z">
<meta property="article:author" content="IMTE">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="IMTE" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">IMTE</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-运输层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/02/%E8%BF%90%E8%BE%93%E5%B1%82/" class="article-date">
  <time datetime="2019-03-02T10:25:33.000Z" itemprop="datePublished">2019-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      运输层
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p><code>运输层</code>位于<code>应用层</code>和<code>网络层</code>之间，为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。</p>
<h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信，即不同主机上的进程能彼此发送报文而无需考虑承载这些报文的物理基础的细节。  </p>
<p>端系统实现运输层协议，而非路由器。在发送端，运输层将从应用程序进程接收到的把稳转换成运输层分组（即运输层报文段）并向目的地发送；在接收端，网络层从数据报中提取出运输层报文，并将该报文段上交给运输层，运输层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层处理接收到的报文段，使该报文段中的数据为接收应用进程使用。</p>
<p>网络应用程序可以使用多种的运输层协议，因特网中有<code>TCP</code>和<code>UDP</code>，每种协议都能为调用的应用程序提供一组不同的运输层服务。</p>
<h3 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h3><p>在协议栈中，运输层位于网络层之上。网络层提供了主机之间的逻辑通信，而运输层协议为运行在不同主机上的进程之间提供了逻辑通信。</p>
<p>计算机网络可以安排多种运输层协议，每种协议为应用程序提供不同的服务模型。运输层协议将来自应用进程的报文移动到网络边缘，但对有关这些报文在网络核心中如何移动不做任何规定。中间路由器既不处理也不识别运输层加在运输层报文中的任何信息。</p>
<p>运输协议能够提供的服务常常受制于底层网络协议的服务模型。如果网络层协议无法为主机之间发送的报文提供时延和带宽保证的话，运输层也就无法为进程之间发送的应用层报文提供时延或带宽保证。</p>
<p>底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。例如，网络层协议会使分组丢失、篡改和冗余，运输协议也能为应用程序提供可靠的数据传输服务；即使网络层不能保证运输层报文段的机密性，运输协议也能使用加密来确保应用程序报文不被入侵者读取。</p>
<h3 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h3><p>因特网网络层协议即<code>网际协议（IP）</code>，它的服务模型是提供<code>尽力而为交付服务（best-effort delivery service）</code>。它尽最大的努力在通信的主机之间交付报文段，但不做任何确保，即<code>不确保交付、报文段的顺序、报文段的完整性</code>，故被称为不可靠服务。</p>
<p>UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为<code>运输层的多路复用与多路分解</code>。</p>
<p>TCP和UDP可以通过在其报文段首部中包括差错检测字段提供完整性检查。进程到进程的<code>数据交付</code>和<code>差错检查</code>是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。UDP流量不可调节，应用程序可以根据其需要以其愿意的任何速率发送数据。</p>
<p>TCP为应用程序提供了可靠数据传输，通过使用流量控制、序号、确认和定时器，TCP能确保按序地、正确地将数据从发送进程交付给接收进程。TCP还提供拥塞控制，它防止任何一条TCP连接用过多流量来淹没通信主机间的链路和交换设备。</p>
<h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p><code>多路分解</code>：将运输层报文段中的数据交付到正确的套接字中的工作。<br><code>多路复用</code>：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层的工作。</p>
<p>运输层多路复用要求：</p>
<blockquote>
<ol>
<li>套接字有唯一的标识符；  </li>
<li>每个报文段都有特殊字段来指示该报文段所要交付到的套接字，这些特殊字段是<code>源端口号</code>和<code>目的端口号</code>字段。</li>
</ol>
</blockquote>
<p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。</p>
<h3 id="无连接的多路复用与多路分解"><a href="#无连接的多路复用与多路分解" class="headerlink" title="无连接的多路复用与多路分解"></a>无连接的多路复用与多路分解</h3><p>一个UDP套接字是由一个二元组来全面标识的，该二元组包含一个目的IP地址和一个目的端口号。</p>
<h3 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h3><p>TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的，两个具有不同IP地址或端口号的到达TCP报文将被定向到两个不同的套接字，除非TCP报文携带了初始创建连接的请求。</p>
<h3 id="web服务与TCP"><a href="#web服务与TCP" class="headerlink" title="web服务与TCP"></a>web服务与TCP</h3><p>当客户向web服务器发送报文段时，所有的报文段（包括初始连接建立报文段和承载HTTP请求的报文段）的目的端口都是80。</p>
<p>如果客户与服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换HTTP报文。如果客户与服务器使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭。</p>
<h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>UDP只做了运输协议能够做的最少工作：复用/分解功能、少量的差错检测。</p>
<p>UDP的优点：</p>
<blockquote>
<p>1.关于何时、发送什么数据的应用层控制更为精细。<br>2.无需建立连接，不会引入建立连接的时延。<br>3.无连接状态。TCP需要在端系统中维护连接状态。这个状态包括接收和发送缓存、拥塞控制参数以及序号和确认号的参数。<br>4.分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。</p>
</blockquote>
<p>UDP的应用：RIP路由选择表的更新、承载网络管理数据（SNMP）、流式音频应用。</p>
<h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><p>UDP首部有四个字段，每个字段由两个字节组成。</p>
<blockquote>
<p>1.源端口号；<br>2.目的端口号；<br>3.长度字段：指示了在UDP报文段中的字节数（首部加数据）；<br>4.检验和：用来检查在该报文段中是否出现了差错。</p>
</blockquote>
<h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>UDP检验和提供了差错检测功能，检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。</p>
<p>发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段。</p>
<p>在接收方，全部的16比特字（包括检验和）加在一起，如果该分组没有引入差错，则在接收方处该和将是1111111111111111。</p>
<p>UDP检验和的必要性：由于不能保证源和目的之间的所有链路都提供差错检测，也无法确保在传输时路由器内存中不引入差错，无法确保逐链路的可靠性，又无法确保内存中的差错检测，UDP就必须在端到端基础上在运输层提供差错检测。</p>
<p>虽然UDP提供差错检测，但它不提供差错恢复，当报文中出现差错时，UDP丢弃受损的报文或向应用程序交付报文段并给出警告。</p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p><code>可靠数据传输协议</code>的服务抽象是：数据可以通过一条可靠的信道进行传输。<br>即：</p>
<blockquote>
<p>1.传输数据比特不会受到损坏或丢失；<br>2.所有数据都是按照其发送顺序进行交付。</p>
</blockquote>
<h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><p><code>自动重传请求（ARQ）协议</code>：接收方向发送方发送控制报文，使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。</p>
<p>ARQ协议中的功能：</p>
<blockquote>
<p>1.差错检测；<br>2.接收方反馈：肯定确认（ACK）和否定确认（NAK）；<br>3.重传</p>
</blockquote>
<p>考虑受损ACK和NAK的情况，当发送方收到含糊不清的ACK和NAK分组时，只需重传当前的数据分组即可。另一个解决办法是在数据分组中添加一新字段，将发送数据分组的序号放在该字段，接收方只需检测序号即可确定收到的分组是否一次重传。  </p>
<p>基于时间的重传机制，引入<code>倒计数定时器</code>：在一个给定的时间量过期后，可中断发送方。<br>发送方需要做到：</p>
<blockquote>
<p>1.每次发送一个分组时，便启动一个定时器；<br>2.响应定时器中断（采取适当的动作）；<br>3.终止定时器。</p>
</blockquote>
<p>通过使用检验和、序号、定时器、肯定和否定确认分组技术，可实现可靠数据传输。</p>
<h3 id="流水线可靠数据传输服务"><a href="#流水线可靠数据传输服务" class="headerlink" title="流水线可靠数据传输服务"></a>流水线可靠数据传输服务</h3><p>停等协议：在发送方确信接收方已正确接收当前分组之前，发送方将不会发送一块新数据。停等协议的方法送分利用率非常低，为了解决这一问题，引入了以下技术。<br><code>流水线</code>：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。<br>流水线技术对可靠数据传输协议可带来如下影响：  </p>
<blockquote>
<p>1.必须增加序号范围<br>2.协议的发送方和接收方两端也必须缓存多个分组。<br>3.所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：<code>回退N步（GBN）</code>、<code>选择重传（SR）</code>。</p>
</blockquote>
<h3 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h3><p><code>回退N步（GBN）协议</code>：允许发送方发送多个分组而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数。<br>回退N步协议保持一个在序号范围内长度为N的窗口，是出于流量控制，对发送方施加限制。<br>GBN发送方必须响应三种类型的事件：  </p>
<blockquote>
<p>1.上层的调用，响应上层调用时，发送方首先检测发送窗口是否已满：若窗口未满，则产生一个分组并将其发送；若窗口未满发送方只需将数据返回给上层，隐式地指示上层窗口已满。<br>2.收到一个ACK：对分组的确认采用累积确认的方式，表明接收方已正确收到序号为n的以前包括n在内的所有分组。<br>3.超时事件：如果出现超时，发送方重传所有已发送但还未被确认过的分组，如果收到一个ACK，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已发送但未被确认的分组，该定时器被终止。  </p>
</blockquote>
<p>GBN接收方的动作：如果一个序号为n的分组被正确接收到，<code>并且按序</code>，则接收方为分组n发送一个ACK，并将该分组中的数据部分交付到上层。在其它所有情况下，丢弃该分组，并为最近按序接收的分组重新发送ACK。  </p>
<p>在GBN中，发送方必须维护窗口的上下边界及nextseqnum在该窗口中的位置，但接收方需要维护的唯一信息就是下一个按序接收的分组的序号。</p>
<h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><p>随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥，选择重传（SR）协议通过让对方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。</p>
<p>SR发送方的事件与动作：</p>
<blockquote>
<p>1.从上层收到数据：从上层收到数据后，SR发送方检查下一个可用于该分组的序号，若序号位于发送方的窗口内，则将数据打包发送，否则同GBN。<br>2.超时：每个分组必须拥有自己的逻辑定时器，超时发生后只能发送一个分组。<br>3.收到ACK：若ACK对应分组的序号在窗口内，则SR发送方将那个被确认的分组标记为已接收，过序号为send_base，则移动窗口到具有最小序号的未确认分组处。窗口移动了且有序号落在窗口内的未发送分组，则发送这些分组。  </p>
</blockquote>
<p>SR接收方的事件与动作：</p>
<blockquote>
<p>1.序号在[rcv_base, rcv_base+N-1]内的分组被正确接收：收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。若该分组以前没有收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号（rcv_base），则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。<br>2.序号在[rcv_base-N, rcv_base-1]内的分组被正确收到：必须产生一个ACK，即使该分组时接收方以前已确认过的分组。<br>3.其它情况：忽略该分组。  </p>
</blockquote>
<p>应用SR协议时，窗口长度必须小于或等于序号空间大小的一半。</p>
<h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><p>TCP实现可靠数据传输，依赖于差错检测、重传、累积确认、定时器以及用于序号和确认号的首部字段。  </p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP的连接状态会完全保留在两个端系统中。中间的网络元素不会维持TCP连接状态。中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接。</p>
<p>TCP连接提供的是全双工服务，应用层数据可在从进程B流向进程A的同时，也从进程A流向进程B。</p>
<p><code>最大报文长度（MSS）</code>：TCP可从缓存中取出并放入报文段中的数据量受限于MSS（报文段里应用层数据的最大长度，不包括TCP首部），MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即<code>最大传输单元MTU</code>）来设置。MSS的值要保证一个TCP报文段加上TCP/IP首部长度将适合单个链路层帧，以太网和PPP链路层协议都具有1500字节的MTU，MSS的典型值为1460字节。</p>
<p>TCP数据传输过程：TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段，这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的接收缓存中，应用程序从此缓存中读取数据流。</p>
<p>TCP的连接组成包括：发送方和接收方两台主机上的缓存、变量和与进程连接的套接字。</p>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p>TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。</p>
<p>首部一般是20字节，其结构为：</p>
<blockquote>
<p>1.<code>源端口号</code>和<code>目的端口号</code>：用于多路复用/分解来自或送到上层应用的数据；<br>2.<code>检验和字段</code>；<br>3.32比特的<code>序号字段</code>和32比特的<code>确认号字段</code>：被TCP发送方和接收方用来实现可靠数据传输服务；<br>4.16比特的<code>接收窗口字段</code>：用于流量控制，指示接收方愿意接受的字节数量；<br>5.4比特的<code>首部长度字段</code>：指示了以32比特的字节为单位的TCP首部长度；<br>6.可选与变长的<code>选项字段</code>：用于发送方与接收方协商最大报文段（MSS）时，或在告诉网络环境下用作窗口调节因子时使用；<br>7.6比特的<code>标志字段</code>：ACK比特用于指示确认字段中的值是有效的，RST、SYN和FIN比特用于连接建立和拆除。当PSH比特被设置的时候，指示接收方应立即将数据交给上层，URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据，紧急数据存在并给出指向紧急数据尾的指针的时候，TCP必须通知接收端的上层实体。</p>
</blockquote>
<h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p>这是TCP报文段首部中两个最重要的字段。</p>
<p>报文段的序号是该报文段首字节的字节流编号，一条TCP连接的双方均可随机地选择初始编号。</p>
<p>累积确认：TCP只确认该流中至第一个丢失字节为止的字节。</p>
<h3 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h3><p>大多数TCP的实现仅在某个时刻做一次SampleRTT(样本往返时间）测量，且绝不为已被重传的报文段就算SampleRTT。<br>一旦获得一个新SampleRTT时，TCP就会根据下列公式来更新EstimatedRTT:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EstimatedRTT&#x3D;(1-a)*EstimatedRTT+a*SampleRTT</span><br></pre></td></tr></table></figure>

<p>[RFC 6298]中给出的a的参考值为0.125，这种平均被称为指数加权移动平均（EWMA）。  </p>
<p>RTT偏差DevRTT，用于估算SampleRTT一般会偏离EstimatedRTT的程度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DevRTT&#x3D;(1-b)*DevRTT+b|DevRTT-EstimatedRTT|</span><br></pre></td></tr></table></figure>

<p>b的推荐值为0.25，如果SampleRTT的值波动较小，DevRTT的值就会变小，vise verse。</p>
<p>TCP重传超时间隔TimeoutInterval:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeoutInterval&#x3D;EstimatedRTT+4*DevRTT</span><br></pre></td></tr></table></figure>

<p>推荐的初始TimeoutInterval值为1秒，当出现超时后，TimeoutInterval的值将加倍。</p>
<h3 id="可靠数据传输-1"><a href="#可靠数据传输-1" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流。</p>
<p>TCP只用超时来恢复报文段的丢失，TCP与发送和重传有关的主要事件：</p>
<blockquote>
<p>1.从应用程序接收数据：TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP，TCP启动定时器，定时器的过期间隔是TimeoutInterval。<br>2.超时：TCP通过重传引起超时的报文段来响应超时事件。然后重启定时器。<br>3.接收方确认报文段（ACK）的到达：TCP将ACK的值y与它的变量SendBase进行比较，如果y大于SendBase，则该ACK是在确认一个或多个先前未被确认的报文段，发送方更新它的SendBase变量；若当前有未被确认的报文段，TCP还要重启定时器。</p>
</blockquote>
<p>超时时间间隔加倍：每次TCP重传时都将下一次的超时间隔设为先前的两倍，每当定时器在收到上层应用的数据或收到ACK时，TimeoutInterval由最近的EstimatedRTT和DevRTT值推算得到。</p>
<p>快速重传：一旦收到3个冗余ACK，TCP就在该报文段的定时器过期之前重传丢失的报文段。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制将发送方的速率与接收方应用程序的读取速率相匹配，意在消除发送方使接收方缓存溢出的可能性。</p>
<p>TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制。  </p>
<p>下式必须成立：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastByteRcvd-LastByteRead&lt;&#x3D;RcvBuffer</span><br></pre></td></tr></table></figure>

<p>接收窗口rwnd根据可用空间的数量来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwnd&#x3D;RcvBuffer-[LastByteRead-LastByteRcvd]</span><br></pre></td></tr></table></figure>

<p>发送方在连接的整个生命周期内必须保证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastByteSent-LastByteAcked&lt;&#x3D;rwnd</span><br></pre></td></tr></table></figure>

<p>当接收方的接收窗口为0时，发送方继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认，当缓存开始清空，确认报文里将包含一个非0的rwnd值。</p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>三次握手：</p>
<blockquote>
<p>1.客户端TCP首先向服务端的TCP发送一个特殊的报文段，该报文中不包含应用层数据，但是在报文段首部的标志位（SYN比特）被置为1。客户随机选择一个初始序号（client_isn），并将此编号防止在起始的TCP SYN报文段的序号字段中；<br>2.包含TCP SYN报文段的IP数据报到达服务器主机，服务器从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户TCP发送允许连接的报文段（SYNACK报文段）。该报文段中SYN比特被置为1，首部的确认号字段被置为client_isn+1。服务器选择自己的初始序号（server_isn），并将其防止到TCP报文段首部的序号字段中；<br>3.客户收到SYNACK报文段后，为该连接分配缓存和变量，客户主机性服务器发送另外一个报文段，这最后一个报文段对服务器的允许连接的报文段进行了确认，SYN比特被置为0，确认报文可以在报文段负载中携带客户到服务器的数据。</p>
</blockquote>
<p>建立连接后的每一个报文段中，SYN比特都将被置为0.</p>
<p>四次挥手：</p>
<blockquote>
<p>1.客户TCP向服务器进程发送一个特殊的TCP报文段，首部中的FIN比特标志位被置为1；<br>2.服务器收到该报文，向发送方回送一个确认报文段；<br>3.服务器发送它自己的终止报文段，其FIN比特被置为1；<br>4.客户对这个服务器的终止报文段进行确认。</p>
</blockquote>
<p>若服务器收到一个SYN请求，但端口号或源IP地址与该主机上进行中的套接字不匹配，则服务器向该主机发送一个特殊重置报文段。该报文段将RST标志位置为1。</p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>拥塞控制的必要性：若链路上的路由器具有无穷大缓存的路由器，当分组的到达速率接近链路容量时，分组经历巨大的排队时延；若链路上的路由器具有有限缓存，发送方发送速率过大引起路由器缓存溢出，发送方必须执行重传以补偿因缓存溢出而丢失的分组，当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量被浪费。</p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p><code>端到端拥塞控制</code>： 在此方法中，网络层没有为运输层拥塞控制提供显式支持，TCP使用增加的往返时延值作为网络拥塞程度增加的指示。</p>
<p><code>网络辅助的拥塞控制</code>：网络层构件向发送方提供关于网络中拥塞状态的显式反馈信息。在此方法中，网络层可用两种方法发送反馈信息：采用阻塞分组的形式、路由器标记或更新从发送方流向接收方分组中的某个字段来指示拥塞的产生。</p>
<h4 id="例子：ATM-ABR拥塞控制"><a href="#例子：ATM-ABR拥塞控制" class="headerlink" title="例子：ATM ABR拥塞控制"></a>例子：ATM ABR拥塞控制</h4><p><code>ATM</code>:异步传递方式网络<br><code>ABR</code>:可用比特率</p>
<p>对于ATM ABR服务，数据信源从源经过一系列中间交换机传输到目的地。在数据信源中夹杂着资源管理信元（RM信元），这些RM信元可被用来在主机和交换机之间传递与拥塞相关的信息。当一个RM信元到达目的地时，它将被调转方向并向发送方发送。交换机也有可能自己产生一个RM信元，并将该RM信元直接发送给源。</p>
<p>ABR提供三种机制用于从交换机向接收方发送与拥塞相关的信令信息：</p>
<blockquote>
<p><code>EFCI比特</code>：每个数据信元都包含1比特的显示转发拥塞指示（EFCI）比特，某拥塞网络的交换机可把一个数据信元中的EFCI比特置为1来向目的主机发送网络已经拥塞的信令。当RM信元到达目的地时，如果多数近来收到的数据信元的拥塞指示比特（CI比特）都被置为1，则目的地就会将RM信元的拥塞指示比特置为1，并将该RM信元发送回接收方。使用数据信元中的EFCI比特和RM信元中的CI比特，发送方因而能够在网络交换机拥塞时得到通知。<br><code>CI和NI比特</code>：RM信元的夹杂比率是一个可调参数，默认值是每32个数据信元中有一个RM信元。这些RM信元中有一个拥塞指示（CI）比特和无增长（NI）比特，这两个比特可被一台拥塞的交换机设置。交换机可在轻微拥塞时将经过的RM信元的NI比特置为1，在严重拥塞时，把CI比特置为1，目的主机收到RM信元时，把该RM信元发回给发送方而保持NI和CI比特不变。<br><code>ER的设置</code>：每一个RM信元还包含一个两字节的显式速率（ER）字段。拥塞的交换机也许会降低经过RM信元中ER字段所包含的值，ER字段将被设置为在源至目的地的路径上的所有交换机中的最小可支持速率。</p>
</blockquote>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP必须使用端到端拥塞控制而不是使用网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。</p>
<p>TCP所使用的原则：</p>
<ul>
<li>一个丢失的报文段意味着拥塞，因此当丢失报文段时应降低TCP发送方的速率。一个超时事件或四个确认被解释为跟随报文段的丢包事件的隐含的指示，对此，TCP发送方应减小它的拥塞窗口长度以减小其发送速率。</li>
<li>一个确认报文段指示该网络正在向接收方交付发送方的报文段。因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。</li>
<li>带宽探测：TCP在ACK到达时增加其速率，当出现丢包时减小其速率。TCP发送方增加它的传输速率，从丢包时的速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化。</li>
</ul>
<p>TCP拥塞控制算法包括三个主要部分：<code>慢启动</code>、<code>拥塞避免</code>、<code>快速恢复</code>。</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>TCP发送方希望迅速找到可用带宽的数量，在慢启动状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。</p>
<p>结束慢启动的三种方式：</p>
<ul>
<li>1.如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1MSS并重新开始慢启动过程。它还将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2。</li>
<li>2.当检测到拥塞时sstresh设为cwnd的一半，当达到或超过ssthresh的值时，结束慢启动并且TCP转移到<code>拥塞避免</code>模式。</li>
<li>3.当检测到3个冗余ACK，TCP执行一次快速重传并进入<code>快速恢复</code>状态。</li>
</ul>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>TCP发送方无论何时到达一个新的确认，就将cwnd增加一个<code>MSS(MSS/cwnd)</code>字节。当丢包事件出现时,ssthresh的值被更新为cwnd的一半，当出现超时时，cwnd的值被设置为1MSS。</p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。如果出现超时事件，快速恢复执行如同在慢启动和拥塞避免中的相同动作后，迁移到慢启动状态。</p>
<p>快速恢复是TCP推荐的而非必须的构建。</p>
<blockquote>
<p>四天时间摘要复习完运输层这一章，详细了解了运输层的运行机制，其中TCP拥塞控制这部分还需要反复琢磨。  </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/03/02/%E8%BF%90%E8%BE%93%E5%B1%82/" data-id="ckja57eeh000cfq130wuu90uu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/05/%E7%BD%91%E7%BB%9C%E5%B1%82/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          网络层
        
      </div>
    </a>
  
  
    <a href="/2019/02/13/%E5%BA%94%E7%94%A8%E5%B1%82/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">应用层</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/celery/" rel="tag">celery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85/" rel="tag">背包</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/celery/" style="font-size: 10px;">celery</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/tool/" style="font-size: 13.33px;">tool</a> <a href="/tags/web/" style="font-size: 16.67px;">web</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E8%83%8C%E5%8C%85/" style="font-size: 10px;">背包</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/03/LeetCode-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/">LeetCode-种花问题</a>
          </li>
        
          <li>
            <a href="/2020/12/30/%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AF%E6%9E%84%E6%88%90%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/">计算数组中可构成三角形的个数</a>
          </li>
        
          <li>
            <a href="/2020/12/30/%E6%B1%82%E4%B8%80%E4%B8%AA%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">求一个无序数组的中位数</a>
          </li>
        
          <li>
            <a href="/2020/12/30/LeetCode-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/">LeetCode-最后一块石头的重量</a>
          </li>
        
          <li>
            <a href="/2020/12/29/LeetCode-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/">LeetCode-按要求补齐数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 IMTE<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>